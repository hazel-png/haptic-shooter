<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no"/>
    <title>Haptic Dot Shooter</title>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700&display=swap" rel="stylesheet">
    <style>
        :root {
            --combo-saturate: 100%; /* コンボ演出用の彩度変数 */
        }

        body {
            margin: 0;
            background: #000000; /* 1. ベースは黒やダークトーン */
            overflow: hidden;
            font-family: -apple-system, BlinkMacSystemFont, "SF Pro", 'Inter', sans-serif;
            color: #E0E0E0;
            display: flex;
            justify-content: center;
            align-items: center;
            width: 100vw;
            min-height: 100dvh;
            position: relative;
            user-select: none;
            -webkit-font-smoothing: antialiased;
            -moz-osx-font-smoothing: grayscale;
            perspective: 1200px;
            transform-style: preserve-3d;
        }

        #radarCanvas {
            width: 100vw;
            height: 100dvh;
            touch-action: none;
            display: block;
            position: absolute;
            top: 0;
            left: 0;
            z-index: 1;
            transform: translateZ(-150px);
        }

        /* ------------------------- */
        /* 撃破・コンボフィードバック */
        /* ------------------------- */
        .hit-particle {
            position: absolute;
            background: rgba(255, 255, 255, 0.9);
            border-radius: 50%;
            opacity: 0;
            animation: particleExplosion 0.6s ease-out forwards;
            pointer-events: none;
            z-index: 6;
            transform-style: preserve-3d;
            box-shadow: 0 0 5px rgba(255, 255, 255, 0.5);
        }

        @keyframes particleExplosion {
            0% {
                transform: translate(-50%, -50%) scale(0) translateZ(10px);
                opacity: 1;
            }
            100% {
                transform: translate(calc(-50% + var(--translate-x)), calc(-50% + var(--translate-y))) scale(1) translateZ(-20px);
                opacity: 0;
            }
        }

        .score-popup {
            position: absolute;
            color: #00FF5A;
            font-size: clamp(0.8rem, 3.5vw, 1.4rem);
            font-weight: 700;
            font-family: inherit;
            animation: scoreFadeOut 0.9s cubic-bezier(0.165, 0.84, 0.44, 1) forwards;
            opacity: 0;
            pointer-events: none;
            z-index: 7;
            text-shadow: 0 0 5px rgba(0, 0, 0, 0.6);
            transform-style: preserve-3d;
            filter: saturate(var(--combo-saturate)); /* コンボ演出と連動 */
        }

        @keyframes scoreFadeOut {
            0% {
                transform: translateY(0) scale(1) translateZ(15px);
                opacity: 1;
            }
            20% {
                transform: translateY(-15px) scale(1.1) translateZ(25px);
            }
            100% {
                transform: translateY(-50px) scale(0.7) translateZ(35px);
                opacity: 0;
            }
        }

        /* ------------------------- */
        /* スコア & コンボ表示 */
        /* ------------------------- */
        #scoreDisplay {
            position: fixed;
            top: 2.5vh;
            left: 50%;
            transform: translateX(-50%) translateZ(30px);
            font-size: clamp(2rem, 8vw, 3.5rem);
            font-weight: 700;
            color: #FFFFFF;
            text-shadow: 0 0 15px rgba(0, 0, 0, 0.7);
            z-index: 10;
            font-family: inherit;
            background: rgba(0, 0, 0, 0.3);
            padding: 1vh 2vw;
            border-radius: 8px;
            min-width: 15vw;
            text-align: center;
            transition: transform 0.2s ease-out, box-shadow 0.2s ease-out;
            filter: saturate(var(--combo-saturate)); /* 6. コンボ演出で盛り上げる */
        }

        #scoreDisplay.vibrate {
            animation: scoreVibrate 0.1s linear infinite alternate;
        }
        @keyframes scoreVibrate {
            from { transform: translateX(-50%) translateZ(30px) translateY(-2px); }
            to { transform: translateX(-50%) translateZ(30px) translateY(2px); }
        }


        #comboDisplay {
            position: fixed;
            top: 10.5vh;
            left: 50%;
            transform: translateX(-50%) translateZ(25px);
            font-size: clamp(1.4rem, 5.5vw, 2.5rem);
            font-weight: 700;
            color: #00FF5A;
            text-shadow: 0 0 10px rgba(0, 0, 0, 0.6);
            z-index: 10;
            font-family: inherit;
            opacity: 0;
            transform-style: preserve-3d;
            background: rgba(0, 0, 0, 0.3);
            padding: 0.8vh 2vw;
            border-radius: 8px;
            transition: opacity 0.3s ease-out, transform 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275);
            white-space: nowrap;
            filter: saturate(var(--combo-saturate)); /* 6. コンボ演出で盛り上げる */
        }

        #comboDisplay.active {
            opacity: 1;
            transform: translateX(-50%) translateY(0) scale(1) translateZ(35px);
            box-shadow: 0 0 20px rgba(0, 255, 90, 0.6), 0 0 30px rgba(0, 255, 90, 0.4), 0 0 40px rgba(0, 255, 90, 0.2);
            animation: comboRingRotate 4s linear infinite; /* 6. コンボ演出で盛り上げる */
        }

        @keyframes comboRingRotate {
            from { box-shadow: 0 0 20px rgba(0, 255, 90, 0.6), 0 0 30px rgba(0, 255, 90, 0.4), 0 0 40px rgba(0, 255, 90, 0.2); }
            to { box-shadow: 0 0 20px rgba(0, 255, 90, 0.6), 0 0 30px rgba(0, 255, 90, 0.4), 0 0 40px rgba(0, 255, 90, 0.2); transform: translateX(-50%) translateY(0) scale(1) translateZ(35px) rotateZ(360deg); }
        }

        /* ------------------------- */
        /* 操作フィードバック UI */
        /* ------------------------- */
        .ripple-effect {
            position: absolute;
            border-radius: 50%;
            background: rgba(0, 255, 90, 0.4);
            animation: ripple 0.4s ease-out forwards;
            pointer-events: none;
            z-index: 8;
            transform: translate(-50%, -50%) translateZ(40px);
        }

        @keyframes ripple {
            0% {
                transform: translate(-50%, -50%) scale(0) translateZ(40px);
                opacity: 1;
            }
            100% {
                transform: translate(-50%, -50%) scale(2) translateZ(40px);
                opacity: 0;
            }
        }

        /* ------------------------- */
        /* 終了・リトライ画面 */
        /* ------------------------- */
        #gameOverScreen {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100dvh;
            background: rgba(0, 0, 0, 0.95);
            backdrop-filter: blur(25px) saturate(150%);
            -webkit-backdrop-filter: blur(25px) saturate(150%);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            color: #E0E0E0;
            font-size: 2rem;
            z-index: 100;
            opacity: 0;
            visibility: hidden;
            transition: opacity 0.8s ease-in-out, transform 0.8s ease-in-out, background 0.8s ease-in-out;
            border-radius: 0;
            transform-style: preserve-3d;
            transform: translateZ(50px) scale(0.9);
            padding: 5vh;
            box-sizing: border-box;
        }

        #gameOverScreen.visible {
            opacity: 1;
            visibility: visible;
            transform: translateZ(150px) scale(1);
        }

        #gameOverScreen h2 {
            font-size: clamp(2.8rem, 11vw, 5.5rem);
            color: #00FF5A;
            margin-bottom: 3vh;
            text-shadow: 0 0 20px rgba(0, 255, 90, 0.7);
            font-weight: 700;
            transform: translateZ(15px);
        }

        #finalScore {
            font-size: clamp(1.8rem, 7vw, 3.5rem);
            margin-bottom: 7vh;
            color: #FFFFFF;
            text-shadow: 0 0 15px rgba(255, 255, 255, 0.6);
            font-family: inherit;
            font-weight: 600;
            transform: translateZ(10px);
        }

        #restartButton {
            padding: 2.2vh 6vw;
            background: rgba(0, 255, 90, 0.2);
            border: 2px solid rgba(0, 255, 90, 0.8);
            border-radius: 50px;
            color: #FFFFFF;
            font-size: clamp(1.5rem, 5vw, 2.2rem);
            font-weight: 700;
            cursor: pointer;
            transition: all 0.3s cubic-bezier(0.2, 0.8, 0.2, 1);
            box-shadow: 0 8px 30px rgba(0, 0, 0, 0.8), inset 0 0 15px rgba(0, 255, 90, 0.4);
            font-family: inherit;
            transform-style: preserve-3d;
            transform: translateZ(20px);
            overflow: hidden;
            position: relative;
        }

        #restartButton::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 255, 90, 0.0);
            transition: background 0.3s ease;
            z-index: -1;
        }

        #restartButton:hover::before {
            background: rgba(0, 255, 90, 0.15);
        }

        #restartButton:active {
            transform: scale(0.95) translateZ(15px);
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.6), inset 0 0 8px rgba(0, 255, 90, 0.6);
            transition: all 0.1s ease-out;
        }

        /* ------------------------- */
        /* スタート画面 */
        /* ------------------------- */
        #startScreen {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100dvh;
            background: #000000;
            color: #FFFFFF;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            font-size: 5vw;
            z-index: 200;
            text-align: center;
            font-family: inherit;
            cursor: pointer;
            transition: opacity 0.6s ease-out, transform 0.6s ease-out;
            transform-style: preserve-3d;
            transform: translateZ(200px);
        }

        #startScreen.hidden {
            opacity: 0;
            pointer-events: none;
            transform: translateZ(0px);
        }

        #startScreen p {
            font-size: clamp(2rem, 7vw, 3.5rem);
            font-weight: 700;
            color: #00FF5A;
            text-shadow: 0 0 10px rgba(0, 0, 0, 0.6);
            transform: translateZ(8px);
            margin-bottom: 3.5vh;
        }

        #startScreen span {
            font-size: clamp(0.8rem, 3vw, 1.3rem);
            opacity: 0.85;
            color: #ccc;
            text-shadow: 0 0 5px rgba(0, 0, 0, 0.3);
            transform: translateZ(5px);
        }
    </style>
</head>
<body>
    <canvas id="radarCanvas"></canvas>
    <div id="scoreDisplay">0</div>
    <div id="comboDisplay"></div>
    <div id="gameOverScreen">
        <h2>GAME OVER</h2>
        <div id="finalScore">FINAL SCORE: 0</div>
        <button id="restartButton">RESTART</button>
    </div>

    <div id="startScreen">
        <p>TAP TO START</p>
        <span>(センサーと音声を有効にします)</span>
    </div>

    <script>
        const canvas = document.getElementById("radarCanvas");
        const ctx = canvas.getContext("2d");
        const scoreDisplay = document.getElementById("scoreDisplay");
        const comboDisplay = document.getElementById("comboDisplay");
        const gameOverScreen = document.getElementById("gameOverScreen");
        const finalScore = document.getElementById("finalScore");
        const restartButton = document.getElementById("restartButton");
        const startScreen = document.getElementById("startScreen");

        let enemies = [];
        let deviceOrientationOffset = 0;
        let cx;
        let cy;
        let score = 0;
        let isGameOver = false;
        let shootCooldown = false;
        const SHOOT_COOLDOWN_TIME = 350;

        let comboCount = 0;
        let lastKillTime = 0;
        const COMBO_RESET_TIME = 1200;

        let audioContext;
        let enemySpawnInterval;

        // Canvasの論理サイズと中心座標を設定する関数
        function setCanvasDimensions() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
            cx = canvas.width / 2;
            cy = canvas.height / 2;
        }

        // バイブレーション関数を抽象化
        function vibrateDevice(pattern) {
            if (navigator.vibrate) {
                navigator.vibrate(pattern);
            }
        }

        function generateSound(frequency, duration, type = 'sine', volume = 0.5) {
            if (!audioContext) return;
            const oscillator = audioContext.createOscillator();
            const gainNode = audioContext.createGain();

            oscillator.connect(gainNode);
            gainNode.connect(audioContext.destination);

            oscillator.type = type;
            oscillator.frequency.setValueAtTime(frequency, audioContext.currentTime);
            gainNode.gain.setValueAtTime(volume, audioContext.currentTime);
            gainNode.gain.exponentialRampToValueAtTime(0.0001, audioContext.currentTime + duration);

            oscillator.start(audioContext.currentTime);
            oscillator.stop(audioContext.currentTime + duration);
        }

        function initGame() {
            enemies = [];
            score = 0;
            comboCount = 0;
            lastKillTime = 0;
            isGameOver = false;
            shootCooldown = false;
            scoreDisplay.textContent = "0";
            comboDisplay.textContent = "";
            comboDisplay.classList.remove("active");
            gameOverScreen.classList.remove("visible");
            deviceOrientationOffset = 0;
            document.documentElement.style.setProperty('--combo-saturate', '100%'); // 彩度をリセット

            if (enemySpawnInterval) clearInterval(enemySpawnInterval);
            enemySpawnInterval = setInterval(spawnEnemy, 2000);
            gameLoop();
        }

        function requestDeviceOrientationPermissionAndStartGame() {
            if (!audioContext) {
                audioContext = new (window.AudioContext || window.webkitAudioContext)();
            }

            if (typeof DeviceOrientationEvent !== 'undefined' && typeof DeviceOrientationEvent.requestPermission === 'function') {
                DeviceOrientationEvent.requestPermission()
                    .then(permissionState => {
                        if (permissionState === 'granted') {
                            window.addEventListener("deviceorientation", handleDeviceOrientation);
                            startScreen.classList.add('hidden');
                            initGame();
                            canvas.addEventListener("click", handleShoot);
                        } else {
                            alert('ジャイロセンサーの利用が拒否されました。ゲームをプレイできません。ブラウザの設定で許可が必要な場合があります。');
                        }
                    })
                    .catch(error => {
                        console.error("DeviceOrientationEvent.requestPermission error:", error);
                        alert('ジャイロセンサーの許可リクエスト中にエラーが発生しました。お使いのデバイスが対応しているか確認してください。');
                    });
            } else {
                window.addEventListener("deviceorientation", handleDeviceOrientation);
                startScreen.classList.add('hidden');
                initGame();
                canvas.addEventListener("click", handleShoot);
            }
        }

        function handleDeviceOrientation(e) {
            if (e.alpha !== null) {
                deviceOrientationOffset = -e.alpha * Math.PI / 180;
            }
        }

        // 2. 敵の色は色相環的に配置 - 角度からHSL色を生成するヘルパー関数
        function getHslColorFromAngle(angle) {
            const hue = (angle / (2 * Math.PI)) * 360; // 0-360度の色相
            const saturation = 100; // 彩度は高めに
            const lightness = 70; // 初期明度
            return `hsl(${hue}, ${saturation}%, ${lightness}%)`;
        }

        function spawnEnemy() {
            if (isGameOver) return;
            const angle = Math.random() * 2 * Math.PI;
            const initialDistance = Math.max(window.innerWidth, window.innerHeight) / 2 * 1.2;
            enemies.push({
                angle: angle,
                distance: initialDistance,
                speed: 0.8 + Math.random() * 0.5,
                health: 1,
                isApproaching: false,
                isTargeted: false,
                initialColor: getHslColorFromAngle(angle) // 初期色を設定
            });
        }

        function updateEnemies() {
            const radarRadius = Math.min(canvas.width, canvas.height) * 0.4;

            enemies.forEach(e => {
                e.distance -= e.speed;
                // 5. 危険度は振動＋明るさで示す
                if (e.distance < radarRadius * 0.7 && !e.isApproaching) {
                    e.isApproaching = true;
                    vibrateDevice([30, 20, 30]); // 振動
                    generateSound(440, 0.05, 'sawtooth', 0.3);
                }
            });
            enemies = enemies.filter(e => {
                if (e.distance <= 15) {
                    endGame();
                    return false;
                }
                return true;
            });

            if (comboCount > 0 && performance.now() - lastKillTime > COMBO_RESET_TIME) {
                comboCount = 0;
                comboDisplay.classList.remove("active");
                comboDisplay.style.transition = 'opacity 0.5s ease-out, transform 0.5s ease-in';
                comboDisplay.style.opacity = '0';
                comboDisplay.style.transform = 'translateX(-50%) translateY(20px) scale(0.8) translateZ(18px)';
                document.documentElement.style.setProperty('--combo-saturate', '100%'); // 彩度をリセット
                setTimeout(() => {
                    comboDisplay.textContent = "";
                    comboDisplay.style.transition = 'opacity 0.3s ease-out, transform 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275)';
                }, 500);
            }
        }

        function drawRadar() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            ctx.save();
            ctx.translate(cx, cy);
            ctx.rotate(-deviceOrientationOffset);
            ctx.translate(-cx, -cy);

            const radarRadius = Math.min(canvas.width, canvas.height) * 0.4;
            const playerCircleRadius = radarRadius * 0.1;
            const lineWidth = 4;

            // レーダーの半透明ガラス質感
            ctx.fillStyle = 'rgba(0, 0, 0, 0.2)';
            ctx.beginPath();
            ctx.arc(cx, cy, radarRadius, 0, 2 * Math.PI);
            ctx.fill();

            const ringColors = ['#1a1a1a', '#2a2a2a', '#3a3a3a'];
            for (let i = 0; i < ringColors.length; i++) {
                ctx.strokeStyle = ringColors[i];
                ctx.lineWidth = lineWidth;
                ctx.beginPath();
                ctx.arc(cx, cy, radarRadius * (1 - (i + 1) * 0.25), 0, 2 * Math.PI);
                ctx.stroke();
            }

            ctx.shadowColor = "rgba(0, 0, 0, 0.8)";
            ctx.shadowBlur = 20;
            ctx.shadowOffsetX = 0;
            ctx.shadowOffsetY = 0;
            ctx.strokeStyle = "#404040";
            ctx.lineWidth = lineWidth + 2;
            ctx.beginPath();
            ctx.arc(cx, cy, radarRadius, 0, 2 * Math.PI);
            ctx.stroke();

            ctx.shadowBlur = 0;
            ctx.shadowColor = "rgba(0, 0, 0, 0)";

            const fanInnerRadius = playerCircleRadius;
            const fanOuterRadius = radarRadius - ctx.lineWidth / 2;
            const fanAngle = Math.PI * 30 / 180;
            const startAngle = -Math.PI / 2 - fanAngle / 2;
            const endAngle = -Math.PI / 2 + fanAngle / 2;

            const gradient = ctx.createRadialGradient(cx, cy, fanInnerRadius, cx, cy, fanOuterRadius);
            gradient.addColorStop(0, 'rgba(0, 255, 90, 0.8)');
            gradient.addColorStop(0.5, 'rgba(0, 255, 90, 0.5)');
            gradient.addColorStop(0.9, 'rgba(0, 255, 90, 0.1)');
            gradient.addColorStop(1, 'rgba(0, 0, 0, 0)');

            ctx.shadowColor = "rgba(0, 255, 90, 0.5)";
            ctx.shadowBlur = 25;
            ctx.shadowOffsetX = 0;
            ctx.shadowOffsetY = 0;

            ctx.beginPath();
            ctx.moveTo(cx + fanInnerRadius * Math.cos(startAngle), cy + fanInnerRadius * Math.sin(startAngle));
            ctx.arc(cx, cy, fanOuterRadius, startAngle, endAngle);
            ctx.lineTo(cx + fanInnerRadius * Math.cos(endAngle), cy + fanInnerRadius * Math.sin(endAngle));
            ctx.arc(cx, cy, fanInnerRadius, endAngle, startAngle, true);
            ctx.closePath();
            ctx.fillStyle = gradient;
            ctx.fill();

            ctx.shadowBlur = 0;
            ctx.shadowColor = "rgba(0, 0, 0, 0)";

            enemies.forEach(e => {
                const relativeAngle = e.angle;
                const ex = cx + e.distance * Math.cos(relativeAngle);
                const ey = cy + e.distance * Math.sin(relativeAngle);
                
                const enemySize = radarRadius * 0.025;
                
                // 5. 危険度は振動＋明るさで示す：距離に応じて赤から白へ変化
                let enemyColor = e.initialColor; // 2. 敵の色は色相環的に配置 - 初期色
                const distanceRatio = e.distance / radarRadius; // 0 (中心) から 1 (外縁)

                if (distanceRatio < 0.3) { // 非常に近い（赤から白へ）
                    const ratio = distanceRatio / 0.3; // 0-1
                    const r = Math.floor(255);
                    const g = Math.floor(255 * ratio);
                    const b = Math.floor(255 * ratio);
                    enemyColor = `rgb(${r}, ${g}, ${b})`; // 赤から白に近づく
                } else if (distanceRatio < 0.7) { // 近い（オレンジから赤へ）
                    const ratio = (distanceRatio - 0.3) / 0.4; // 0-1
                    const r = Math.floor(255);
                    const g = Math.floor(255 * (1 - ratio)); // 緑成分を減らす
                    const b = 0;
                    enemyColor = `rgb(${r}, ${g}, ${b})`; // オレンジから赤
                } else { // 遠い（初期色）
                    // HSLをRGBに変換して彩度・明度を調整する関数が必要だが、
                    // 簡易的に彩度を落として表示
                    // Note: CanvasのfillStyleにHSLを直接指定できないため、ここではRGBに変換済みと仮定
                    // 例: HSL(h, s, l) => RGB(r, g, b)
                    const tempHue = (e.angle / (2 * Math.PI)) * 360;
                    const tempSaturation = 100 * (0.5 + 0.5 * (distanceRatio - 0.7) / 0.3); // 遠いほど彩度低め
                    const tempLightness = 50 * (0.5 + 0.5 * (distanceRatio - 0.7) / 0.3); // 遠いほど暗め
                    enemyColor = `hsl(${tempHue}, ${tempSaturation}%, ${tempLightness}%)`;
                }

                const absoluteShootAngle = normalizeAngle(startAngle + fanAngle / 2 + deviceOrientationOffset);
                const diff = Math.abs(normalizeAngle(e.angle - absoluteShootAngle));
                const currentShootRange = fanAngle;

                if (diff < currentShootRange / 2 && e.distance < (radarRadius - ctx.lineWidth / 2)) {
                    e.isTargeted = true;
                    ctx.strokeStyle = "#00FF5A";
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.arc(ex, ey, enemySize + 3, 0, 2 * Math.PI);
                    ctx.stroke();
                } else {
                    e.isTargeted = false;
                }
                
                ctx.fillStyle = enemyColor;
                ctx.beginPath();
                ctx.arc(ex, ey, enemySize, 0, 2 * Math.PI);
                ctx.fill();
            });

            ctx.shadowColor = "rgba(0, 255, 90, 0.8)";
            ctx.shadowBlur = 20;
            ctx.shadowOffsetX = 0;
            ctx.shadowOffsetY = 0;
            
            ctx.fillStyle = '#00FF5A';
            ctx.beginPath();
            ctx.moveTo(cx + playerCircleRadius * 1.5 * Math.cos(-Math.PI / 2), cy + playerCircleRadius * 1.5 * Math.sin(-Math.PI / 2));
            ctx.lineTo(cx + playerCircleRadius * Math.cos(-Math.PI / 2 + Math.PI * 0.75), cy + playerCircleRadius * Math.sin(-Math.PI / 2 + Math.PI * 0.75));
            ctx.lineTo(cx + playerCircleRadius * Math.cos(-Math.PI / 2 - Math.PI * 0.75), cy + playerCircleRadius * Math.sin(-Math.PI / 2 - Math.PI * 0.75));
            ctx.closePath();
            ctx.fill();
            
            ctx.shadowBlur = 0;
            ctx.shadowColor = "rgba(0, 0, 0, 0)";

            ctx.restore();
        }

        function normalizeAngle(angle) {
            return Math.atan2(Math.sin(angle), Math.cos(angle));
        }

        function gameLoop() {
            if (isGameOver) return;
            updateEnemies();
            drawRadar();
            requestAnimationFrame(gameLoop);
        }

        function createHitParticles(x, y, count = 10) {
            for (let i = 0; i < count; i++) {
                const particle = document.createElement("div");
                particle.className = "hit-particle";
                
                const angle = Math.random() * Math.PI * 2;
                const distance = Math.random() * 50 + 20; // 広がる距離を少し大きく
                const size = Math.random() * 8 + 2;
                
                particle.style.left = `${x}px`;
                particle.style.top = `${y}px`;
                particle.style.width = `${size}px`;
                particle.style.height = `${size}px`;
                
                // 4. アニメーションで動きをつける - 撃破時はカラフルに弾ける
                const colors = ['#FF6F61', '#FFD166', '#00B8D4', '#00D1B2', '#E040FB', '#FFFFFF']; // 白も追加
                particle.style.background = colors[Math.floor(Math.random() * colors.length)];
                
                const translateX = distance * Math.cos(angle);
                const translateY = distance * Math.sin(angle);

                // アニメーションキーフレームを動的に生成（以前の修正で追加済み）
                // ここでCSS変数を設定し、アニメーション内で利用
                particle.style.setProperty('--translate-x', `${translateX}px`);
                particle.style.setProperty('--translate-y', `${translateY}px`);

                document.body.appendChild(particle);
                setTimeout(() => particle.remove(), 600);
            }
        }


        function createRippleEffect(x, y) {
            const ripple = document.createElement("div");
            ripple.className = "ripple-effect";
            ripple.style.left = `${x}px`;
            ripple.style.top = `${y}px`;
            ripple.style.width = ripple.style.height = `min(15vw, 60px)`;
            document.body.appendChild(ripple);
            setTimeout(() => ripple.remove(), 400);
        }

        function updateScore(points) {
            const oldScore = score;
            score += points;
            
            let currentScore = oldScore;
            const diff = score - oldScore;
            const duration = 300;
            const startTime = performance.now();

            function animateScore() {
                const now = performance.now();
                const elapsed = now - startTime;
                if (elapsed < duration) {
                    const progress = elapsed / duration;
                    scoreDisplay.textContent = Math.floor(oldScore + diff * progress).toString();
                    requestAnimationFrame(animateScore);
                } else {
                    scoreDisplay.textContent = score.toString();
                }
            }
            animateScore();

            // 6. コンボ演出で盛り上げる - スコアが大幅に伸びるとUI全体が軽く振動
            if (score > 0 && score % 5000 === 0) {
                scoreDisplay.classList.add('vibrate');
                vibrateDevice([50, 20, 50]);
                generateSound(1500, 0.1, 'sine', 0.7); // 派手な音
                setTimeout(() => {
                    scoreDisplay.classList.remove('vibrate');
                }, 300);
            }
        }

        function endGame() {
            if (isGameOver) return;
            isGameOver = true;
            vibrateDevice([200, 100, 200, 100, 200]);
            generateSound(200, 0.4, 'square', 0.6);
            if (enemySpawnInterval) clearInterval(enemySpawnInterval);
            finalScore.textContent = `FINAL SCORE: ${score}`;
            gameOverScreen.classList.add("visible");
            canvas.removeEventListener("click", handleShoot);
        }

        function handleShoot(event) {
            if (isGameOver || shootCooldown) return;
            
            createRippleEffect(event.clientX, event.clientY);
            generateSound(880, 0.08, 'sine', 0.4);
            vibrateDevice([20, 10, 20]);
            
            shootCooldown = true;
            setTimeout(() => {
                shootCooldown = false;
            }, SHOOT_COOLDOWN_TIME);

            const shootAngle = -Math.PI / 2;
            const radarRadius = Math.min(canvas.width, canvas.height) * 0.4;
            const fanAngle = Math.PI * 30 / 180;

            enemies = enemies.filter(e => {
                const absoluteShootAngle = normalizeAngle(shootAngle + deviceOrientationOffset);
                const diff = Math.abs(normalizeAngle(e.angle - absoluteShootAngle));

                if (diff < fanAngle / 2 && e.distance < (radarRadius - ctx.lineWidth / 2)) {
                    e.health--;
                    if (e.health <= 0) {
                        const ex = cx + e.distance * Math.cos(e.angle);
                        const ey = cy + e.distance * Math.sin(e.angle);
                        createHitParticles(ex, ey, 15);
                        
                        const currentTime = performance.now();
                        if (currentTime - lastKillTime < COMBO_RESET_TIME) {
                            comboCount++;
                        } else {
                            comboCount = 1;
                        }
                        lastKillTime = currentTime;

                        let comboText = "";
                        if (comboCount > 1) {
                            comboText = `${comboCount} COMBO!`;
                            comboDisplay.classList.add("active");
                            // 6. コンボ演出で盛り上げる - リングやスコアの彩度上昇
                            const saturateValue = Math.min(100 + comboCount * 10, 300); // 最大300%
                            document.documentElement.style.setProperty('--combo-saturate', `${saturateValue}%`);

                            if (comboCount >= 3 && comboCount % 3 === 0) {
                                vibrateDevice([30]);
                                generateSound(1200, 0.05, 'triangle', 0.8);
                            }
                        } else {
                             comboDisplay.classList.remove("active");
                             document.documentElement.style.setProperty('--combo-saturate', '100%'); // リセット
                        }
                        
                        let currentCombo = parseInt(comboDisplay.textContent.split(' ')[0]) || 0;
                        if (comboCount > currentCombo) {
                            const comboDiff = comboCount - currentCombo;
                            const comboDuration = 200;
                            const comboStartTime = performance.now();

                            function animateCombo() {
                                const now = performance.now();
                                const elapsed = now - comboStartTime;
                                if (elapsed < comboDuration) {
                                    const progress = elapsed / comboDuration;
                                    comboDisplay.textContent = `${Math.floor(currentCombo + comboDiff * progress)} COMBO! ${getComboIcon(Math.floor(currentCombo + comboDiff * progress))}`;
                                    requestAnimationFrame(animateCombo);
                                } else {
                                    comboDisplay.textContent = comboText + getComboIcon(comboCount);
                                }
                            }
                            animateCombo();
                        } else {
                            comboDisplay.textContent = comboText + getComboIcon(comboCount);
                        }

                        let points = 100;
                        if (comboCount >= 2) {
                            points = Math.floor(points * (1 + comboCount * 0.2));
                        }
                        updateScore(points);
                        showScorePopup(ex, ey, points, comboCount); // スコアポップアップにも彩度影響
                        vibrateDevice([40, 30, 40]);
                        generateSound(1000, 0.1, 'triangle', 0.5);
                        return false;
                    }
                }
                return true;
            });
        }

        function getComboIcon(count) {
            if (count >= 10) return '⚡️⚡️⚡️';
            if (count >= 5) return '⚡️⚡️';
            if (count >= 2) return '⚡️';
            return '';
        }

        function showScorePopup(x, y, points, combo) {
            const popup = document.createElement('div');
            popup.className = 'score-popup';
            popup.textContent = `+${points}`;
            popup.style.left = `${x}px`;
            popup.style.top = `${y}px`;
            // スコアポップアップもコンボの彩度上昇を反映
            popup.style.filter = `saturate(${document.documentElement.style.getPropertyValue('--combo-saturate')})`;
            document.body.appendChild(popup);
            setTimeout(() => popup.remove(), 900);
        }

        restartButton.addEventListener("click", () => {
            initGame();
            canvas.addEventListener("click", handleShoot); 
        });

        window.onload = () => {
            setCanvasDimensions(); 
            startScreen.classList.remove('hidden');
        };

        startScreen.addEventListener('click', requestDeviceOrientationPermissionAndStartGame);

        window.addEventListener('resize', () => {
            setCanvasDimensions(); 
        });

    </script>
</body>
</html>
