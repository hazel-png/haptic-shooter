<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no"/>
    <title>Haptic Dot Shooter</title>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700&display=swap" rel="stylesheet">
    <style>
        :root {
            --combo-saturate: 100%; /* コンボ演出用の彩度変数 */
            --player-zone-color: rgba(0, 255, 90, 0.4); /* ゾーンの色 */
            --player-zone-border-color: rgba(0, 255, 90, 0.8); /* ゾーンのボーダー色 */
            --player-zone-blur: 0px; /* ゾーン全体のぼかし用変数 */
        }

        body {
            margin: 0;
            background: #000000;
            overflow: hidden;
            font-family: -apple-system, BlinkMacSystemFont, "SF Pro", 'Inter', sans-serif;
            color: #E0E0E0;
            display: flex;
            justify-content: center;
            align-items: center;
            width: 100vw;
            min-height: 100dvh;
            position: relative;
            user-select: none;
            -webkit-font-smoothing: antialiased;
            -moz-osx-font-smoothing: grayscale;
            perspective: 1200px;
            transform-style: preserve-3d;
        }

        #radarCanvas {
            width: 100vw;
            height: 100dvh;
            touch-action: none;
            display: block;
            position: absolute;
            top: 0;
            left: 0;
            z-index: 1;
            transform: translateZ(-150px);
        }

        /* ------------------------- */
        /* 撃破・コンボフィードバック */
        /* ------------------------- */
        .hit-particle {
            position: absolute;
            background: rgba(255, 255, 255, 0.9);
            border-radius: 50%;
            opacity: 0;
            animation: particleExplosion 0.6s ease-out forwards;
            pointer-events: none;
            z-index: 6;
            transform-style: preserve-3d;
            box-shadow: 0 0 5px rgba(255, 255, 255, 0.5);
        }

        @keyframes particleExplosion {
            0% {
                transform: translate(-50%, -50%) scale(0) translateZ(10px);
                opacity: 1;
            }
            100% {
                transform: translate(calc(-50% + var(--translate-x)), calc(-50% + var(--translate-y))) scale(1) translateZ(-20px);
                opacity: 0;
            }
        }

        .score-popup {
            position: absolute;
            color: #00FF5A;
            font-size: clamp(0.8rem, 3.5vw, 1.4rem);
            font-weight: 700;
            font-family: inherit;
            animation: scoreFadeOut 0.9s cubic-bezier(0.165, 0.84, 0.44, 1) forwards;
            opacity: 0;
            pointer-events: none;
            z-index: 7;
            text-shadow: 0 0 5px rgba(0, 0, 0, 0.6);
            transform-style: preserve-3d;
            filter: saturate(var(--combo-saturate));
        }

        @keyframes scoreFadeOut {
            0% {
                transform: translateY(0) scale(1) translateZ(15px);
                opacity: 1;
            }
            20% {
                transform: translateY(-15px) scale(1.1) translateZ(25px);
            }
            100% {
                transform: translateY(-50px) scale(0.7) translateZ(35px);
                opacity: 0;
            }
        }

        /* ------------------------- */
        /* スコア & コンボ表示 */
        /* ------------------------- */
        #scoreDisplay {
            position: fixed;
            top: 2.5vh;
            left: 50%;
            transform: translateX(-50%) translateZ(30px);
            font-size: clamp(2rem, 8vw, 3.5rem);
            font-weight: 700;
            color: #FFFFFF;
            text-shadow: 0 0 15px rgba(0, 0, 0, 0.7);
            z-index: 10;
            font-family: inherit;
            background: rgba(0, 0, 0, 0.3);
            padding: 1vh 2vw;
            border-radius: 8px;
            min-width: 15vw;
            text-align: center;
            transition: transform 0.2s ease-out, box-shadow 0.2s ease-out;
            filter: saturate(var(--combo-saturate));
        }

        #scoreDisplay.vibrate {
            animation: scoreVibrate 0.1s linear infinite alternate;
        }
        @keyframes scoreVibrate {
            from { transform: translateX(-50%) translateZ(30px) translateY(-2px); }
            to { transform: translateX(-50%) translateZ(30px) translateY(2px); }
        }


        #comboDisplay {
            position: fixed;
            top: 10.5vh;
            left: 50%;
            transform: translateX(-50%) translateZ(25px);
            font-size: clamp(1.4rem, 5.5vw, 2.5rem);
            font-weight: 700;
            color: #00FF5A;
            text-shadow: 0 0 10px rgba(0, 0, 0, 0.6);
            z-index: 10;
            font-family: inherit;
            opacity: 0;
            transform-style: preserve-3d;
            background: rgba(0, 0, 0, 0.3);
            padding: 0.8vh 2vw;
            border-radius: 8px;
            transition: opacity 0.3s ease-out, transform 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275);
            white-space: nowrap;
            filter: saturate(var(--combo-saturate));
        }

        #comboDisplay.active {
            opacity: 1;
            transform: translateX(-50%) translateY(0) scale(1) translateZ(35px);
            box-shadow: 0 0 20px rgba(0, 255, 90, 0.6), 0 0 30px rgba(0, 255, 90, 0.4), 0 0 40px rgba(0, 255, 90, 0.2);
            animation: comboRingRotate 4s linear infinite;
        }

        @keyframes comboRingRotate {
            from { box-shadow: 0 0 20px rgba(0, 255, 90, 0.6), 0 0 30px rgba(0, 255, 90, 0.4), 0 0 40px rgba(0, 255, 90, 0.2); }
            to { box-shadow: 0 0 20px rgba(0, 255, 90, 0.6), 0 0 30px rgba(0, 255, 90, 0.4), 0 0 40px rgba(0, 255, 90, 0.2); transform: translateX(-50%) translateY(0) scale(1) translateZ(35px) rotateZ(360deg); }
        }

        /* ------------------------- */
        /* 操作フィードバック UI */
        /* ------------------------- */
        .ripple-effect {
            position: absolute;
            border-radius: 50%;
            background: rgba(0, 255, 90, 0.4);
            animation: ripple 0.4s ease-out forwards;
            pointer-events: none;
            z-index: 8;
            transform: translate(-50%, -50%) translateZ(40px);
        }

        @keyframes ripple {
            0% {
                transform: translate(-50%, -50%) scale(0) translateZ(40px);
                opacity: 1;
            }
            100% {
                transform: translate(-50%, -50%) scale(2) translateZ(40px);
                opacity: 0;
            }
        }

        /* ------------------------- */
        /* 終了・リトライ画面 */
        /* ------------------------- */
        #gameOverScreen {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100dvh;
            background: rgba(0, 0, 0, 0.95);
            backdrop-filter: blur(25px) saturate(150%);
            -webkit-backdrop-filter: blur(25px) saturate(150%);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            color: #E0E0E0;
            font-size: 2rem;
            z-index: 100;
            opacity: 0;
            visibility: hidden;
            transition: opacity 0.8s ease-in-out, transform 0.8s ease-in-out, background 0.8s ease-in-out;
            border-radius: 0;
            transform-style: preserve-3d;
            transform: translateZ(50px) scale(0.9);
            padding: 5vh;
            box-sizing: border-box;
        }

        #gameOverScreen.visible {
            opacity: 1;
            visibility: visible;
            transform: translateZ(150px) scale(1);
        }

        #gameOverScreen h2 {
            font-size: clamp(2.8rem, 11vw, 5.5rem);
            color: #00FF5A;
            margin-bottom: 3vh;
            text-shadow: 0 0 20px rgba(0, 255, 90, 0.7);
            font-weight: 700;
            transform: translateZ(15px);
        }

        #finalScore {
            font-size: clamp(1.8rem, 7vw, 3.5rem);
            margin-bottom: 7vh;
            color: #FFFFFF;
            text-shadow: 0 0 15px rgba(255, 255, 255, 0.6);
            font-family: inherit;
            font-weight: 600;
            transform: translateZ(10px);
        }

        #restartButton {
            padding: 2.2vh 6vw;
            background: rgba(0, 255, 90, 0.2);
            border: 2px solid rgba(0, 255, 90, 0.8);
            border-radius: 50px;
            color: #FFFFFF;
            font-size: clamp(1.5rem, 5vw, 2.2rem);
            font-weight: 700;
            cursor: pointer;
            transition: all 0.3s cubic-bezier(0.2, 0.8, 0.2, 1);
            box-shadow: 0 8px 30px rgba(0, 0, 0, 0.8), inset 0 0 15px rgba(0, 255, 90, 0.4);
            font-family: inherit;
            transform-style: preserve-3d;
            transform: translateZ(20px);
            overflow: hidden;
            position: relative;
        }

        #restartButton::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 255, 90, 0.0);
            transition: background 0.3s ease;
            z-index: -1;
        }

        #restartButton:hover::before {
            background: rgba(0, 255, 90, 0.15);
        }

        #restartButton:active {
            transform: scale(0.95) translateZ(15px);
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.6), inset 0 0 8px rgba(0, 255, 90, 0.6);
            transition: all 0.1s ease-out;
        }

        /* ------------------------- */
        /* スタート画面 */
        /* ------------------------- */
        #startScreen {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100dvh;
            background: #000000;
            color: #FFFFFF;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            font-size: 5vw;
            z-index: 200;
            text-align: center;
            font-family: inherit;
            cursor: pointer;
            transition: opacity 0.6s ease-out, transform 0.6s ease-out;
            transform-style: preserve-3d;
            transform: translateZ(200px);
        }

        #startScreen.hidden {
            opacity: 0;
            pointer-events: none;
            transform: translateZ(0px);
        }

        #startScreen p {
            font-size: clamp(2rem, 7vw, 3.5rem);
            font-weight: 700;
            color: #00FF5A;
            text-shadow: 0 0 10px rgba(0, 0, 0, 0.6);
            transform: translateZ(8px);
            margin-bottom: 3.5vh;
        }

        #startScreen span {
            font-size: clamp(0.8rem, 3vw, 1.3rem);
            opacity: 0.85;
            color: #ccc;
            text-shadow: 0 0 5px rgba(0, 0, 0, 0.3);
            transform: translateZ(5px);
        }

        /* 攻撃不能メッセージ */
        .attack-disabled-text {
            position: absolute;
            font-size: clamp(0.7rem, 2.5vw, 1.1rem);
            color: rgba(255, 255, 255, 0.7); /* グレー表示 */
            background: rgba(0, 0, 0, 0.5);
            padding: 2px 6px;
            border-radius: 4px;
            transform: translate(-50%, -50%) translateZ(10px);
            pointer-events: none;
            opacity: 0; /* 最初は非表示 */
            transition: opacity 0.3s ease-out;
            white-space: nowrap;
        }
    </style>
</head>
<body>
    <canvas id="radarCanvas"></canvas>
    <div id="scoreDisplay">0</div>
    <div id="comboDisplay"></div>
    <div id="gameOverScreen">
        <h2>GAME OVER</h2>
        <div id="finalScore">FINAL SCORE: 0</div>
        <button id="restartButton">RESTART</button>
    </div>

    <div id="startScreen">
        <p>TAP TO START</p>
        <span>(センサーと音声を有効にします)</span>
    </div>

    <script>
        const canvas = document.getElementById("radarCanvas");
        const ctx = canvas.getContext("2d");
        const scoreDisplay = document.getElementById("scoreDisplay");
        const comboDisplay = document.getElementById("comboDisplay");
        const gameOverScreen = document.getElementById("gameOverScreen");
        const finalScore = document.getElementById("finalScore");
        const restartButton = document.getElementById("restartButton");
        const startScreen = document.getElementById("startScreen");

        let enemies = [];
        let deviceOrientationOffset = 0;
        let cx;
        let cy;
        let score = 0;
        let isGameOver = false;
        let shootCooldown = false;
        const SHOOT_COOLDOWN_TIME = 350;

        let comboCount = 0;
        let lastKillTime = 0;
        const COMBO_RESET_TIME = 1200;

        let audioContext;
        let enemySpawnInterval;

        const PLAYER_ZONE_RADIUS_RATIO = 0.5; // レーダー半径に対するゾーンの半径の割合
        let playerZoneRadius; // プレイヤーのゾーンの実際の半径

        // Canvasの論理サイズと中心座標を設定する関数
        function setCanvasDimensions() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
            cx = canvas.width / 2;
            cy = canvas.height / 2;
            playerZoneRadius = Math.min(canvas.width, canvas.height) * PLAYER_ZONE_RADIUS_RATIO;
        }

        // バイブレーション関数を抽象化
        function vibrateDevice(pattern) {
            if (navigator.vibrate) {
                navigator.vibrate(pattern);
            }
        }

        function generateSound(frequency, duration, type = 'sine', volume = 0.5) {
            if (!audioContext) return;
            const oscillator = audioContext.createOscillator();
            const gainNode = audioContext.createGain();

            oscillator.connect(gainNode);
            gainNode.connect(audioContext.destination);

            oscillator.type = type;
            oscillator.frequency.setValueAtTime(frequency, audioContext.currentTime);
            gainNode.gain.setValueAtTime(volume, audioContext.currentTime);
            gainNode.gain.exponentialRampToValueAtTime(0.0001, audioContext.currentTime + duration);

            oscillator.start(audioContext.currentTime);
            oscillator.stop(audioContext.currentTime + duration);
        }

        function initGame() {
            enemies = [];
            score = 0;
            comboCount = 0;
            lastKillTime = 0;
            isGameOver = false;
            shootCooldown = false;
            scoreDisplay.textContent = "0";
            comboDisplay.textContent = "";
            comboDisplay.classList.remove("active");
            gameOverScreen.classList.remove("visible");
            deviceOrientationOffset = 0;
            document.documentElement.style.setProperty('--combo-saturate', '100%'); // 彩度をリセット

            if (enemySpawnInterval) clearInterval(enemySpawnInterval);
            enemySpawnInterval = setInterval(spawnEnemy, 2000);
            gameLoop();
        }

        function requestDeviceOrientationPermissionAndStartGame() {
            if (!audioContext) {
                audioContext = new (window.AudioContext || window.webkitAudioContext)();
            }

            if (typeof DeviceOrientationEvent !== 'undefined' && typeof DeviceOrientationEvent.requestPermission === 'function') {
                DeviceOrientationEvent.requestPermission()
                    .then(permissionState => {
                        if (permissionState === 'granted') {
                            window.addEventListener("deviceorientation", handleDeviceOrientation);
                            startScreen.classList.add('hidden');
                            initGame();
                            canvas.addEventListener("click", handleShoot);
                        } else {
                            alert('ジャイロセンサーの利用が拒否されました。ゲームをプレイできません。ブラウザの設定で許可が必要な場合があります。');
                        }
                    })
                    .catch(error => {
                        console.error("DeviceOrientationEvent.requestPermission error:", error);
                        alert('ジャイロセンサーの許可リクエスト中にエラーが発生しました。お使いのデバイスが対応しているか確認してください。');
                    });
            } else {
                window.addEventListener("deviceorientation", handleDeviceOrientation);
                startScreen.classList.add('hidden');
                initGame();
                canvas.addEventListener("click", handleShoot);
            }
        }

        function handleDeviceOrientation(e) {
            if (e.alpha !== null) {
                deviceOrientationOffset = -e.alpha * Math.PI / 180;
            }
        }

        // 敵の色を角度からHSL色を生成
        function getHslColorFromAngle(angle) {
            const hue = (angle / (2 * Math.PI)) * 360;
            const saturation = 100;
            const lightness = 70;
            return `hsl(${hue}, ${saturation}%, ${lightness}%)`;
        }

        function spawnEnemy() {
            if (isGameOver) return;
            const angle = Math.random() * 2 * Math.PI;
            // 敵はゾーンの外にスポーン
            const initialDistance = playerZoneRadius * 1.5 + Math.random() * playerZoneRadius * 0.5; // ゾーンの外側から
            enemies.push({
                angle: angle,
                distance: initialDistance,
                speed: 0.8 + Math.random() * 0.5,
                health: 1,
                isApproaching: false,
                isTargeted: false,
                initialColor: getHslColorFromAngle(angle),
                isInZone: false, // ゾーン内にいるかどうかのフラグ
                attackDisabledTextElement: null // 攻撃不可メッセージ用DOM要素
            });
        }

        function updateEnemies() {
            enemies.forEach(e => {
                e.distance -= e.speed;

                const wasInZone = e.isInZone;
                e.isInZone = e.distance <= playerZoneRadius;

                // 敵がゾーンを突破し内側に入った瞬間に彩度を一気にスムーズに上げる + バイブレーション
                if (!wasInZone && e.isInZone) {
                    vibrateDevice([50]); // 攻撃可能になる瞬間のバイブレーション
                    generateSound(660, 0.05, 'triangle', 0.5); // 攻撃可能になった音
                }

                // 5. 危険度は振動＋明るさで示す
                if (e.distance < playerZoneRadius * 0.7 && !e.isApproaching) {
                    e.isApproaching = true;
                    vibrateDevice([30, 20, 30]);
                    generateSound(440, 0.05, 'sawtooth', 0.3);
                }
            });
            enemies = enemies.filter(e => {
                if (e.distance <= 15) {
                    endGame();
                    return false;
                }
                return true;
            });

            if (comboCount > 0 && performance.now() - lastKillTime > COMBO_RESET_TIME) {
                comboCount = 0;
                comboDisplay.classList.remove("active");
                comboDisplay.style.transition = 'opacity 0.5s ease-out, transform 0.5s ease-in';
                comboDisplay.style.opacity = '0';
                comboDisplay.style.transform = 'translateX(-50%) translateY(20px) scale(0.8) translateZ(18px)';
                document.documentElement.style.setProperty('--combo-saturate', '100%');
                setTimeout(() => {
                    comboDisplay.textContent = "";
                    comboDisplay.style.transition = 'opacity 0.3s ease-out, transform 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275)';
                }, 500);
            }
        }

        function drawRadar() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            ctx.save();
            ctx.translate(cx, cy);
            ctx.rotate(-deviceOrientationOffset);
            ctx.translate(-cx, -cy);

            const radarRadius = Math.min(canvas.width, canvas.height) * 0.4;
            const playerCircleRadius = radarRadius * 0.1;
            const lineWidth = 4;

            // レーダーの半透明ガラス質感（背景を透かす表現）
            ctx.fillStyle = 'rgba(0, 0, 0, 0.2)';
            ctx.beginPath();
            ctx.arc(cx, cy, radarRadius, 0, 2 * Math.PI);
            ctx.fill();

            // 1. 正円の枠の構造 - 緑色の正円の枠（ゾーン）
            ctx.strokeStyle = var_to_rgb('--player-zone-border-color'); // CSS変数から取得
            ctx.lineWidth = lineWidth + 2;
            ctx.shadowColor = var_to_rgb('--player-zone-color'); // ゾーンの色を影に
            ctx.shadowBlur = 25;
            ctx.shadowOffsetX = 0;
            ctx.shadowOffsetY = 0;
            ctx.beginPath();
            ctx.arc(cx, cy, playerZoneRadius, 0, 2 * Math.PI);
            ctx.stroke();

            // ゾーンの内側を埋める色
            ctx.fillStyle = var_to_rgb('--player-zone-color');
            ctx.beginPath();
            ctx.arc(cx, cy, playerZoneRadius, 0, 2 * Math.PI);
            ctx.fill();

            // 影の設定をリセット
            ctx.shadowBlur = 0;
            ctx.shadowColor = "rgba(0, 0, 0, 0)";

            // 扇形のグリーンゾーン（プレイヤーの方向）の描画
            const fanInnerRadius = playerCircleRadius;
            const fanOuterRadius = playerZoneRadius - ctx.lineWidth / 2; // ゾーンの内側に合わせる
            const fanAngle = Math.PI * 30 / 180;
            const startAngle = -Math.PI / 2 - fanAngle / 2;
            const endAngle = -Math.PI / 2 + fanAngle / 2;

            const gradient = ctx.createRadialGradient(cx, cy, fanInnerRadius, cx, cy, fanOuterRadius);
            gradient.addColorStop(0, 'rgba(0, 255, 90, 0.8)');
            gradient.addColorStop(0.5, 'rgba(0, 255, 90, 0.5)');
            gradient.addColorStop(0.9, 'rgba(0, 255, 90, 0.1)');
            gradient.addColorStop(1, 'rgba(0, 0, 0, 0)');

            ctx.shadowColor = "rgba(0, 255, 90, 0.5)";
            ctx.shadowBlur = 25;
            ctx.shadowOffsetX = 0;
            ctx.shadowOffsetY = 0;

            ctx.beginPath();
            ctx.moveTo(cx + fanInnerRadius * Math.cos(startAngle), cy + fanInnerRadius * Math.sin(startAngle));
            ctx.arc(cx, cy, fanOuterRadius, startAngle, endAngle);
            ctx.lineTo(cx + fanInnerRadius * Math.cos(endAngle), cy + fanInnerRadius * Math.sin(endAngle));
            ctx.arc(cx, cy, fanInnerRadius, endAngle, startAngle, true);
            ctx.closePath();
            ctx.fillStyle = gradient;
            ctx.fill();

            ctx.shadowBlur = 0;
            ctx.shadowColor = "rgba(0, 0, 0, 0)";

            // 敵の描画
            enemies.forEach(e => {
                const relativeAngle = e.angle;
                const ex = cx + e.distance * Math.cos(relativeAngle);
                const ey = cy + e.distance * Math.sin(relativeAngle);
                
                const enemySize = radarRadius * 0.025;
                
                // 3. 彩度の変化演出 - ゾーン内外で彩度とぼかしを変化
                let enemyColor = e.initialColor;
                let blurAmount = 0;
                let opacity = 1;

                if (!e.isInZone) {
                    // ゾーンの外側：彩度かなり低め（グレーっぽい）で軽くぼかし
                    const hsl = HSLtoRGB(e.initialColor); // HSLからRGBへの変換
                    enemyColor = `rgb(${hsl.r * 0.3 + 255 * 0.7}, ${hsl.g * 0.3 + 255 * 0.7}, ${hsl.b * 0.3 + 255 * 0.7})`; // グレーに近づける
                    blurAmount = 5; // 軽いぼかし
                    opacity = 0.6; // 少し透明に
                } else {
                    // ゾーン内：彩度MAXで鮮やかな色彩に変化
                    const distanceRatio = e.distance / playerZoneRadius; // ゾーン内の距離比
                    if (distanceRatio < 0.3) { // 非常に近い（赤から白へ）
                        const ratio = distanceRatio / 0.3; // 0-1
                        const r = Math.floor(255);
                        const g = Math.floor(255 * ratio);
                        const b = Math.floor(255 * ratio);
                        enemyColor = `rgb(${r}, ${g}, ${b})`; // 赤から白に近づく
                    } else if (distanceRatio < 0.7) { // 近い（初期色から赤へ）
                        // 初期色を赤に近づける処理
                        const initialHsl = HSLtoRGB(e.initialColor);
                        const ratio = (distanceRatio - 0.3) / 0.4; // 0-1
                        const r = Math.floor(initialHsl.r * (1 - ratio) + 255 * ratio);
                        const g = Math.floor(initialHsl.g * (1 - ratio) + 0 * ratio); // 緑成分を減らす
                        const b = Math.floor(initialHsl.b * (1 - ratio) + 0 * ratio); // 青成分を減らす
                        enemyColor = `rgb(${r}, ${g}, ${b})`;
                    } else { // ゾーン内だが遠い（初期色そのまま）
                        enemyColor = e.initialColor;
                    }
                }

                ctx.save();
                ctx.globalAlpha = opacity; // 透明度を設定
                ctx.filter = `blur(${blurAmount}px)`; // ぼかしを設定

                const absoluteShootAngle = normalizeAngle(startAngle + fanAngle / 2 + deviceOrientationOffset);
                const diff = Math.abs(normalizeAngle(e.angle - absoluteShootAngle));
                const currentShootRange = fanAngle;

                // ゾーンに入った敵だけが攻撃可能になる
                if (e.isInZone && diff < currentShootRange / 2) { // ゾーン内かつ照準範囲内
                    e.isTargeted = true;
                    ctx.strokeStyle = "#00FF5A";
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.arc(ex, ey, enemySize + 3, 0, 2 * Math.PI);
                    ctx.stroke();
                } else {
                    e.isTargeted = false;
                }
                
                ctx.fillStyle = enemyColor;
                ctx.beginPath();
                ctx.arc(ex, ey, enemySize, 0, 2 * Math.PI);
                ctx.fill();

                ctx.restore(); // globalAlphaとfilterをリセット

                // 2. 攻撃不可の敵は視覚的に「攻撃不能」というメッセージを色で分かりやすく表示
                if (!e.isInZone) {
                    if (!e.attackDisabledTextElement) {
                        e.attackDisabledTextElement = document.createElement('div');
                        e.attackDisabledTextElement.className = 'attack-disabled-text';
                        e.attackDisabledTextElement.textContent = '攻撃不能';
                        document.body.appendChild(e.attackDisabledTextElement);
                    }
                    e.attackDisabledTextElement.style.left = `${ex + cx * Math.cos(-deviceOrientationOffset) - cx + canvas.width / 2}px`; // 敵のCanvas上の位置をDOMの絶対位置に変換
                    e.attackDisabledTextElement.style.top = `${ey + cy * Math.sin(-deviceOrientationOffset) - cy + canvas.height / 2}px`;
                    e.attackDisabledTextElement.style.opacity = '1';
                } else {
                    if (e.attackDisabledTextElement) {
                        e.attackDisabledTextElement.style.opacity = '0';
                        setTimeout(() => { // アニメーション後に削除
                            if (e.attackDisabledTextElement && !e.isInZone) { // ゾーンを離れた後に削除確認
                                e.attackDisabledTextElement.remove();
                                e.attackDisabledTextElement = null;
                            }
                        }, 300);
                    }
                }
            });

            // 1. プレイヤーを緑色の円に白いボーダーがついているように変更
            ctx.shadowColor = "rgba(0, 255, 90, 0.8)";
            ctx.shadowBlur = 20;
            ctx.shadowOffsetX = 0;
            ctx.shadowOffsetY = 0;
            
            ctx.fillStyle = '#00FF5A'; // 緑色の円
            ctx.beginPath();
            ctx.arc(cx, cy, playerCircleRadius, 0, 2 * Math.PI);
            ctx.fill();

            ctx.strokeStyle = '#FFFFFF'; // 白いボーダー
            ctx.lineWidth = 3;
            ctx.beginPath();
            ctx.arc(cx, cy, playerCircleRadius + 2, 0, 2 * Math.PI); // 少し大きめの円でボーダーを描画
            ctx.stroke();

            ctx.shadowBlur = 0;
            ctx.shadowColor = "rgba(0, 0, 0, 0)";

            ctx.restore();
        }

        function normalizeAngle(angle) {
            return Math.atan2(Math.sin(angle), Math.cos(angle));
        }

        function gameLoop() {
            if (isGameOver) return;
            updateEnemies();
            drawRadar();
            requestAnimationFrame(gameLoop);
        }

        function createHitParticles(x, y, count = 10) {
            for (let i = 0; i < count; i++) {
                const particle = document.createElement("div");
                particle.className = "hit-particle";
                
                const angle = Math.random() * Math.PI * 2;
                const distance = Math.random() * 50 + 20;
                const size = Math.random() * 8 + 2;
                
                particle.style.left = `${x}px`;
                particle.style.top = `${y}px`;
                particle.style.width = `${size}px`;
                particle.style.height = `${size}px`;
                
                const colors = ['#FF6F61', '#FFD166', '#00B8D4', '#00D1B2', '#E040FB', '#FFFFFF'];
                particle.style.background = colors[Math.floor(Math.random() * colors.length)];
                
                const translateX = distance * Math.cos(angle);
                const translateY = distance * Math.sin(angle);

                particle.style.setProperty('--translate-x', `${translateX}px`);
                particle.style.setProperty('--translate-y', `${translateY}px`);

                document.body.appendChild(particle);
                setTimeout(() => particle.remove(), 600);
            }
        }


        function createRippleEffect(x, y) {
            const ripple = document.createElement("div");
            ripple.className = "ripple-effect";
            ripple.style.left = `${x}px`;
            ripple.style.top = `${y}px`;
            ripple.style.width = ripple.style.height = `min(15vw, 60px)`;
            document.body.appendChild(ripple);
            setTimeout(() => ripple.remove(), 400);
        }

        function updateScore(points) {
            const oldScore = score;
            score += points;
            
            let currentScore = oldScore;
            const diff = score - oldScore;
            const duration = 300;
            const startTime = performance.now();

            function animateScore() {
                const now = performance.now();
                const elapsed = now - startTime;
                if (elapsed < duration) {
                    const progress = elapsed / duration;
                    scoreDisplay.textContent = Math.floor(oldScore + diff * progress).toString();
                    requestAnimationFrame(animateScore);
                } else {
                    scoreDisplay.textContent = score.toString();
                }
            }
            animateScore();

            if (score > 0 && score % 5000 === 0) {
                scoreDisplay.classList.add('vibrate');
                vibrateDevice([50, 20, 50]);
                generateSound(1500, 0.1, 'sine', 0.7);
                setTimeout(() => {
                    scoreDisplay.classList.remove('vibrate');
                }, 300);
            }
        }

        function endGame() {
            if (isGameOver) return;
            isGameOver = true;
            vibrateDevice([200, 100, 200, 100, 200]);
            generateSound(200, 0.4, 'square', 0.6);
            if (enemySpawnInterval) clearInterval(enemySpawnInterval);
            finalScore.textContent = `FINAL SCORE: ${score}`;
            gameOverScreen.classList.add("visible");
            canvas.removeEventListener("click", handleShoot);
            // ゲームオーバー時に残っている攻撃不能メッセージを削除
            enemies.forEach(e => {
                if (e.attackDisabledTextElement) {
                    e.attackDisabledTextElement.remove();
                    e.attackDisabledTextElement = null;
                }
            });
        }

        function handleShoot(event) {
            if (isGameOver || shootCooldown) return;
            
            createRippleEffect(event.clientX, event.clientY);
            generateSound(880, 0.08, 'sine', 0.4);
            vibrateDevice([20, 10, 20]);
            
            shootCooldown = true;
            setTimeout(() => {
                shootCooldown = false;
            }, SHOOT_COOLDOWN_TIME);

            const shootAngle = -Math.PI / 2;
            const fanAngle = Math.PI * 30 / 180;

            enemies = enemies.filter(e => {
                // ゾーンに入った敵だけが攻撃可能になる
                if (!e.isInZone) return true; // ゾーン外の敵は攻撃できない

                const absoluteShootAngle = normalizeAngle(shootAngle + deviceOrientationOffset);
                const diff = Math.abs(normalizeAngle(e.angle - absoluteShootAngle));

                if (diff < fanAngle / 2) { // ゾーン内かつ照準範囲内
                    e.health--;
                    if (e.health <= 0) {
                        const ex = cx + e.distance * Math.cos(e.angle);
                        const ey = cy + e.distance * Math.sin(e.angle);
                        createHitParticles(ex, ey, 15);
                        
                        const currentTime = performance.now();
                        if (currentTime - lastKillTime < COMBO_RESET_TIME) {
                            comboCount++;
                        } else {
                            comboCount = 1;
                        }
                        lastKillTime = currentTime;

                        let comboText = "";
                        if (comboCount > 1) {
                            comboText = `${comboCount} COMBO!`;
                            comboDisplay.classList.add("active");
                            const saturateValue = Math.min(100 + comboCount * 10, 300);
                            document.documentElement.style.setProperty('--combo-saturate', `${saturateValue}%`);

                            if (comboCount >= 3 && comboCount % 3 === 0) {
                                vibrateDevice([30]);
                                generateSound(1200, 0.05, 'triangle', 0.8);
                            }
                        } else {
                             comboDisplay.classList.remove("active");
                             document.documentElement.style.setProperty('--combo-saturate', '100%');
                        }
                        
                        let currentCombo = parseInt(comboDisplay.textContent.split(' ')[0]) || 0;
                        if (comboCount > currentCombo) {
                            const comboDiff = comboCount - currentCombo;
                            const comboDuration = 200;
                            const comboStartTime = performance.now();

                            function animateCombo() {
                                const now = performance.now();
                                const elapsed = now - comboStartTime;
                                if (elapsed < comboDuration) {
                                    const progress = elapsed / comboDuration;
                                    comboDisplay.textContent = `${Math.floor(currentCombo + comboDiff * progress)} COMBO! ${getComboIcon(Math.floor(currentCombo + comboDiff * progress))}`;
                                    requestAnimationFrame(animateCombo);
                                } else {
                                    comboDisplay.textContent = comboText + getComboIcon(comboCount);
                                }
                            }
                            animateCombo();
                        } else {
                            comboDisplay.textContent = comboText + getComboIcon(comboCount);
                        }

                        let points = 100;
                        if (comboCount >= 2) {
                            points = Math.floor(points * (1 + comboCount * 0.2));
                        }
                        updateScore(points);
                        showScorePopup(ex, ey, points, comboCount);
                        vibrateDevice([40, 30, 40]);
                        generateSound(1000, 0.1, 'triangle', 0.5);

                        // 撃破された敵の攻撃不能メッセージを削除
                        if (e.attackDisabledTextElement) {
                            e.attackDisabledTextElement.remove();
                            e.attackDisabledTextElement = null;
                        }

                        return false; // 敵を削除
                    }
                }
                return true;
            });
        }

        function getComboIcon(count) {
            if (count >= 10) return '⚡️⚡️⚡️';
            if (count >= 5) return '⚡️⚡️';
            if (count >= 2) return '⚡️';
            return '';
        }

        function showScorePopup(x, y, points, combo) {
            const popup = document.createElement('div');
            popup.className = 'score-popup';
            popup.textContent = `+${points}`;
            popup.style.left = `${x}px`;
            popup.style.top = `${y}px`;
            popup.style.filter = `saturate(${document.documentElement.style.getPropertyValue('--combo-saturate')})`;
            document.body.appendChild(popup);
            setTimeout(() => popup.remove(), 900);
        }

        // HSL文字列からRGBオブジェクトへの変換ヘルパー（簡易版、Canvas用）
        function HSLtoRGB(hslString) {
            const parts = hslString.match(/hsl\((\d+),\s*(\d+)%,\s*(\d+)%\)/);
            if (!parts) return { r: 0, g: 0, b: 0 }; // エラーハンドリング
            let h = parseInt(parts[1]);
            let s = parseInt(parts[2]) / 100;
            let l = parseInt(parts[3]) / 100;

            let c = (1 - Math.abs(2 * l - 1)) * s,
                x = c * (1 - Math.abs((h / 60) % 2 - 1)),
                m = l - c / 2,
                r = 0,
                g = 0,
                b = 0;

            if (0 <= h && h < 60) {
                r = c; g = x; b = 0;
            } else if (60 <= h && h < 120) {
                r = x; g = c; b = 0;
            } else if (120 <= h && h < 180) {
                r = 0; g = c; b = x;
            } else if (180 <= h && h < 240) {
                r = 0; g = x; b = c;
            } else if (240 <= h && h < 300) {
                r = x; g = 0; b = c;
            } else if (300 <= h && h < 360) {
                r = c; g = 0; b = x;
            }
            r = Math.round((r + m) * 255);
            g = Math.round((g + m) * 255);
            b = Math.round((b + m) * 255);

            return { r, g, b };
        }

        // CSS変数からRGBA/RGB文字列を取得するヘルパー関数
        function var_to_rgb(varName) {
            const style = getComputedStyle(document.documentElement);
            return style.getPropertyValue(varName).trim();
        }


        restartButton.addEventListener("click", () => {
            initGame();
            canvas.addEventListener("click", handleShoot); 
        });

        window.onload = () => {
            setCanvasDimensions(); 
            startScreen.classList.remove('hidden');
        };

        startScreen.addEventListener('click', requestDeviceOrientationPermissionAndStartGame);

        window.addEventListener('resize', () => {
            setCanvasDimensions(); 
        });
    </script>
</body>
</html>
