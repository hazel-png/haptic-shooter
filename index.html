<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no"/>
    <title>Haptic Dot Shooter</title>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght%40400%3B600%3B700&display=swap" rel="stylesheet">
    <style>
        :root {
            --combo-saturate: 100%; /* コンボ演出用の彩度変数 */
        }

        body {
            margin: 0;
            background: #000000; /* 1. ベースは黒やダークトーン */
            overflow: hidden;
            font-family: -apple-system, BlinkMacMacFont, "SF Pro", 'Inter', sans-serif;
            color: #E0E0E0;
            display: flex;
            justify-content: center;
            align-items: center;
            width: 100vw;
            min-height: 100dvh;
            position: relative;
            user-select: none;
            -webkit-font-smoothing: antialiased;
            -moz-osx-font-smoothing: grayscale;
            perspective: 1200px;
            transform-style: preserve-3d;
        }

        #radarCanvas {
            width: 100vw;
            height: 100dvh;
            touch-action: none; /* タッチジェスチャーのデフォルト動作を無効化 */
            display: block;
            position: absolute;
            top: 0;
            left: 0;
            z-index: 1;
            transform: translateZ(-150px);
        }

        /* ------------------------- */
        /* 撃破・コンボフィードバック */
        /* ------------------------- */
        .hit-particle {
            position: absolute;
            background: rgba(255, 255, 255, 0.9);
            border-radius: 50%;
            opacity: 0;
            animation: particleExplosion 0.6s cubic-bezier(0.175, 0.885, 0.32, 1.275) forwards; /* Spring Animation風 */
            pointer-events: none;
            z-index: 6;
            transform-style: preserve-3d;
            box-shadow: 0 0 5px rgba(255, 255, 255, 0.5);
            /* filter: blur(0px); */ /* モーションブラーはCanvas描画では難しい */
        }

        @keyframes particleExplosion {
            0% {
                transform: translate(-50%, -50%) scale(0) translateZ(10px);
                opacity: 1;
            }
            100% {
                transform: translate(calc(-50% + var(--translate-x)), calc(-50% + var(--translate-y))) scale(1) translateZ(-20px);
                opacity: 0;
            }
        }

        .score-popup {
            position: absolute;
            color: #00FF5A;
            font-size: clamp(0.8rem, 3.5vw, 1.4rem);
            font-weight: 700;
            font-family: inherit;
            animation: scoreFadeOut 0.9s cubic-bezier(0.165, 0.84, 0.44, 1) forwards;
            opacity: 0;
            pointer-events: none;
            z-index: 7;
            text-shadow: 0 0 5px rgba(0, 0, 0, 0.6);
            transform-style: preserve-3d;
            filter: saturate(var(--combo-saturate));
        }

        @keyframes scoreFadeOut {
            0% {
                transform: translateY(0) scale(1) translateZ(15px);
                opacity: 1;
            }
            20% {
                transform: translateY(-15px) scale(1.1) translateZ(25px);
            }
            100% {
                transform: translateY(-50px) scale(0.7) translateZ(35px);
                opacity: 0;
            }
        }

        /* ------------------------- */
        /* スコア & コンボ表示 */
        /* ------------------------- */
        #scoreDisplay {
            position: fixed;
            top: 2.5vh;
            left: 50%;
            transform: translateX(-50%) translateZ(30px);
            font-size: clamp(2rem, 8vw, 3.5rem);
            font-weight: 700;
            color: #FFFFFF;
            text-shadow: 0 0 15px rgba(0, 0, 0, 0.7);
            z-index: 10;
            font-family: inherit;
            background: rgba(0, 0, 0, 0.3);
            padding: 1vh 2vw;
            border-radius: 8px;
            min-width: 15vw;
            text-align: center;
            transition: transform 0.2s ease-out, box-shadow 0.2s ease-out, filter 0.3s ease-out; /* filterもトランジション */
            filter: saturate(var(--combo-saturate));
        }

        #scoreDisplay.vibrate {
            animation: scoreVibrate 0.1s linear infinite alternate;
        }
        @keyframes scoreVibrate {
            from { transform: translateX(-50%) translateZ(30px) translateY(-2px); }
            to { transform: translateX(-50%) translateZ(30px) translateY(2px); }
        }


        #comboDisplay {
            position: fixed;
            top: 10.5vh;
            left: 50%;
            transform: translateX(-50%) translateZ(25px);
            font-size: clamp(1.4rem, 5.5vw, 2.5rem);
            font-weight: 700;
            color: #00FF5A;
            text-shadow: 0 0 10px rgba(0, 0, 0, 0.6);
            z-index: 10;
            font-family: inherit;
            opacity: 0;
            transform-style: preserve-3d;
            background: rgba(0, 0, 0, 0.3);
            padding: 0.8vh 2vw;
            border-radius: 8px;
            transition: opacity 0.3s ease-out, transform 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275), filter 0.3s ease-out; /* filterもトランジション */
            white-space: nowrap;
            filter: saturate(var(--combo-saturate));
        }

        #comboDisplay.active {
            opacity: 1;
            transform: translateX(-50%) translateY(0) scale(1) translateZ(35px);
            box-shadow: 0 0 20px rgba(0, 255, 90, 0.6), 0 0 30px rgba(0, 255, 90, 0.4), 0 0 40px rgba(0, 255, 90, 0.2);
            animation: comboRingRotate 4s linear infinite;
        }

        @keyframes comboRingRotate {
            from { box-shadow: 0 0 20px rgba(0, 255, 90, 0.6), 0 0 30px rgba(0, 255, 90, 0.4), 0 0 40px rgba(0, 255, 90, 0.2); }
            to { box-shadow: 0 0 20px rgba(0, 255, 90, 0.6), 0 0 30px rgba(0, 255, 90, 0.4), 0 0 40px rgba(0, 255, 90, 0.2); transform: translateX(-50%) translateY(0) scale(1) translateZ(35px) rotateZ(360deg); }
        }

        /* ------------------------- */
        /* 操作フィードバック UI */
        /* ------------------------- */
        .ripple-effect {
            position: absolute;
            border-radius: 50%;
            background: rgba(0, 255, 90, 0.4);
            animation: ripple 0.4s cubic-bezier(0.175, 0.885, 0.32, 1.275) forwards; /* Spring Animation風 */
            pointer-events: none;
            z-index: 8;
            transform: translate(-50%, -50%) translateZ(40px);
        }

        @keyframes ripple {
            0% {
                transform: translate(-50%, -50%) scale(0) translateZ(40px);
                opacity: 1;
            }
            100% {
                transform: translate(-50%, -50%) scale(2) translateZ(40px);
                opacity: 0;
            }
        }

        /* ------------------------- */
        /* 終了・リトライ画面 */
        /* ------------------------- */
        #gameOverScreen {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100dvh;
            background: rgba(0, 0, 0, 0.95);
            backdrop-filter: blur(25px) saturate(150%);
            -webkit-backdrop-filter: blur(25px) saturate(150%);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            color: #E0E0E0;
            font-size: 2rem;
            z-index: 100;
            opacity: 0;
            visibility: hidden;
            transition: opacity 0.8s ease-in-out, transform 0.8s cubic-bezier(0.2, 0.8, 0.2, 1), background 0.8s ease-in-out;
            border-radius: 0;
            transform-style: preserve-3d;
            transform: translateZ(50px) scale(0.9);
            padding: 5vh;
            box-sizing: border-box;
        }

        #gameOverScreen.visible {
            opacity: 1;
            visibility: visible;
            transform: translateZ(150px) scale(1);
        }

        #gameOverScreen h2 {
            font-size: clamp(2.8rem, 11vw, 5.5rem);
            color: #00FF5A;
            margin-bottom: 3vh;
            text-shadow: 0 0 20px rgba(0, 255, 90, 0.7);
            font-weight: 700;
            transform: translateZ(15px);
        }

        #finalScore {
            font-size: clamp(1.8rem, 7vw, 3.5rem);
            margin-bottom: 7vh;
            color: #FFFFFF;
            text-shadow: 0 0 15px rgba(255, 255, 255, 0.6);
            font-family: inherit;
            font-weight: 600;
            transform: translateZ(10px);
        }

        #restartButton {
            padding: 2.2vh 6vw;
            background: rgba(0, 255, 90, 0.2);
            border: 2px solid rgba(0, 255, 90, 0.8);
            border-radius: 50px;
            color: #FFFFFF;
            font-size: clamp(1.5rem, 5vw, 2.2rem);
            font-weight: 700;
            cursor: pointer;
            transition: all 0.3s cubic-bezier(0.2, 0.8, 0.2, 1);
            box-shadow: 0 8px 30px rgba(0, 0, 0, 0.8), inset 0 0 15px rgba(0, 255, 90, 0.4);
            font-family: inherit;
            transform-style: preserve-3d;
            transform: translateZ(20px);
            overflow: hidden;
            position: relative;
        }

        #restartButton::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 255, 90, 0.0);
            transition: background 0.3s ease;
            z-index: -1;
        }

        #restartButton:hover::before {
            background: rgba(0, 255, 90, 0.15);
        }

        #restartButton:active {
            transform: scale(0.95) translateZ(15px);
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.6), inset 0 0 8px rgba(0, 255, 90, 0.6);
            transition: all 0.1s ease-out;
        }

        /* ------------------------- */
        /* スタート画面 */
        /* ------------------------- */
        #startScreen {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100dvh;
            background: #000000;
            color: #FFFFFF;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            font-size: 5vw;
            z-index: 200;
            text-align: center;
            font-family: inherit;
            cursor: pointer;
            transition: opacity 0.6s ease-out, transform 0.6s cubic-bezier(0.2, 0.8, 0.2, 1); /* Spring Animation風 */
            transform-style: preserve-3d;
            transform: translateZ(200px);
        }

        #startScreen.hidden {
            opacity: 0;
            pointer-events: none;
            transform: translateZ(0px);
        }

        #startScreen p {
            font-size: clamp(2rem, 7vw, 3.5rem);
            font-weight: 700;
            color: #00FF5A;
            text-shadow: 0 0 10px rgba(0, 0, 0, 0.6);
            transform: translateZ(8px);
            margin-bottom: 3.5vh;
        }

        #startScreen span {
            font-size: clamp(0.8rem, 3vw, 1.3rem);
            opacity: 0.85;
            color: #ccc;
            text-shadow: 0 0 5px rgba(0, 0, 0, 0.3);
            transform: translateZ(5px);
        }
    </style>
</head>
<body>
    <canvas id="radarCanvas"></canvas>
    <div id="scoreDisplay">0</div>
    <div id="comboDisplay"></div>
    <div id="gameOverScreen">
        <h2>GAME OVER</h2>
        <div id="finalScore">FINAL SCORE: 0</div>
        <button id="restartButton">RESTART</button>
    </div>

    <div id="startScreen">
        <p>TAP TO START</p>
        <span>(センサーと音声を有効にします)</span>
    </div>

    <script>
        const canvas = document.getElementById("radarCanvas");
        const ctx = canvas.getContext("2d");
        const scoreDisplay = document.getElementById("scoreDisplay");
        const comboDisplay = document.getElementById("comboDisplay");
        const gameOverScreen = document.getElementById("gameOverScreen");
        const finalScore = document.getElementById("finalScore");
        const restartButton = document.getElementById("restartButton");
        const startScreen = document.getElementById("startScreen");

        let enemies = [];
        let deviceOrientationOffset = 0;
        let cx;
        let cy;
        let score = 0;
        let isGameOver = false;
        let shootCooldown = false;
        const SHOOT_COOLDOWN_TIME = 350;

        let comboCount = 0;
        let lastKillTime = 0;
        const COMBO_RESET_TIME = 1200;

        let audioContext;
        let enemySpawnInterval;

        let lastShakeTime = 0;
        const SHAKE_THRESHOLD = 15; // 加速度の閾値 (調整可能)
        const SHAKE_COOLDOWN = 500; // シェイクのクールダウン (ms)

        let attackZoneRadius; // ゾーンの半径をグローバル変数で管理

        // Canvasの論理サイズと中心座標を設定する関数
        function setCanvasDimensions() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
            cx = canvas.width / 2;
            cy = canvas.height / 2;
            attackZoneRadius = Math.min(canvas.width, canvas.height) * 0.3; // ゾーンの半径を定義
        }

        // バイブレーション関数を抽象化
        function vibrateDevice(pattern) {
            if (navigator.vibrate) {
                navigator.vibrate(pattern);
            }
        }

        function generateSound(frequency, duration, type = 'sine', volume = 0.5) {
            if (!audioContext) return;
            const oscillator = audioContext.createOscillator();
            const gainNode = audioContext.createGain();

            oscillator.connect(gainNode);
            gainNode.connect(audioContext.destination);

            oscillator.type = type;
            oscillator.frequency.setValueAtTime(frequency, audioContext.currentTime);
            gainNode.gain.setValueAtTime(volume, audioContext.currentTime);
            gainNode.gain.exponentialRampToValueAtTime(0.0001, audioContext.currentTime + duration);

            oscillator.start(audioContext.currentTime);
            oscillator.stop(audioContext.currentTime + duration);
        }

        function initGame() {
            enemies = [];
            score = 0;
            comboCount = 0;
            lastKillTime = 0;
            isGameOver = false;
            shootCooldown = false;
            scoreDisplay.textContent = "0";
            comboDisplay.textContent = "";
            comboDisplay.classList.remove("active");
            gameOverScreen.classList.remove("visible");
            deviceOrientationOffset = 0;
            document.documentElement.style.setProperty('--combo-saturate', '100%'); // 彩度をリセット

            if (enemySpawnInterval) clearInterval(enemySpawnInterval);
            enemySpawnInterval = setInterval(spawnEnemy, 2000);
            gameLoop();
        }

        function requestDeviceOrientationPermissionAndStartGame() {
            if (!audioContext) {
                audioContext = new (window.AudioContext || window.webkitAudioContext)();
            }

            // ジャイロセンサー許可リクエスト
            if (typeof DeviceOrientationEvent !== 'undefined' && typeof DeviceOrientationEvent.requestPermission === 'function') {
                DeviceOrientationEvent.requestPermission()
                    .then(permissionState => {
                        if (permissionState === 'granted') {
                            window.addEventListener("deviceorientation", handleDeviceOrientation);
                            requestDeviceMotionPermissionAndContinue();
                        } else {
                            alert('ジャイロセンサーの利用が拒否されました。ゲームをプレイできません。ブラウザの設定で許可が必要な場合があります。');
                        }
                    })
                    .catch(error => {
                        console.error("DeviceOrientationEvent.requestPermission error:", error);
                        alert('ジャイロセンサーの許可リクエスト中にエラーが発生しました。お使いのデバイスが対応しているか確認してください。');
                    });
            } else {
                // DeviceOrientationEvent.requestPermissionがサポートされていないブラウザの場合
                window.addEventListener("deviceorientation", handleDeviceOrientation);
                requestDeviceMotionPermissionAndContinue();
            }
        }

        function requestDeviceMotionPermissionAndContinue() {
             // 加速度センサー許可リクエスト
            if (typeof DeviceMotionEvent !== 'undefined' && typeof DeviceMotionEvent.requestPermission === 'function') {
                DeviceMotionEvent.requestPermission()
                    .then(permissionState => {
                        if (permissionState === 'granted') {
                            window.addEventListener("devicemotion", handleDeviceMotion);
                            startScreen.classList.add('hidden');
                            initGame();
                            canvas.addEventListener("click", handleShoot); // タップ操作も残す
                        } else {
                            alert('加速度センサーの利用が拒否されました。振る操作ができません。ブラウザの設定で許可が必要な場合があります。');
                            // 加速度センサーがなくてもゲームは開始できるようにする
                            startScreen.classList.add('hidden');
                            initGame();
                            canvas.addEventListener("click", handleShoot);
                        }
                    })
                    .catch(error => {
                        console.error("DeviceMotionEvent.requestPermission error:", error);
                        alert('加速度センサーの許可リクエスト中にエラーが発生しました。お使いのデバイスが対応しているか確認してください。');
                        // 加速度センサーがなくてもゲームは開始できるようにする
                        startScreen.classList.add('hidden');
                        initGame();
                        canvas.addEventListener("click", handleShoot);
                    });
            } else {
                // DeviceMotionEvent.requestPermissionがサポートされていないブラウザの場合
                window.addEventListener("devicemotion", handleDeviceMotion);
                startScreen.classList.add('hidden');
                initGame();
                canvas.addEventListener("click", handleShoot);
            }
        }

        function handleDeviceOrientation(e) {
            if (e.alpha !== null) {
                deviceOrientationOffset = -e.alpha * Math.PI / 180;
            }
        }

        function handleDeviceMotion(e) {
            if (isGameOver) return;
            const acceleration = e.accelerationIncludingGravity;
            if (acceleration && acceleration.z) { // Z軸方向の加速度（画面奥方向）を検出
                const now = performance.now();
                if (Math.abs(acceleration.z) > SHAKE_THRESHOLD && (now - lastShakeTime) > SHAKE_COOLDOWN) {
                    // スマホを上向きに振る（画面が上を向いている前提で、Z軸が減少する方向）
                    // 実際にはY軸（デバイスの前後方向）や、複合的な動きで判断する方が良い場合も
                    // 今回はZ軸（画面の表裏方向）の急激な変化で簡易的に検出
                    if (acceleration.z < -SHAKE_THRESHOLD) { // 画面が上に振られる動き
                        handleShoot();
                        lastShakeTime = now;
                    }
                }
            }
        }

        // 2. 敵の色は色相環的に配置 - 角度からHSL色を生成するヘルパー関数
        function getHslColorFromAngle(angle) {
            const hue = (angle / (2 * Math.PI)) * 360; // 0-360度の色相
            const saturation = 100; // 彩度は高めに
            const lightness = 70; // 初期明度
            return `hsl(${hue}, ${saturation}%, ${lightness}%)`;
        }

        function spawnEnemy() {
            if (isGameOver) return;
            const angle = Math.random() * 2 * Math.PI;
            const initialDistance = Math.max(window.innerWidth, window.innerHeight) / 2 * 1.2;
            enemies.push({
                angle: angle,
                distance: initialDistance,
                speed: 0.8 + Math.random() * 0.5,
                health: 1,
                isApproaching: false,
                isTargeted: false,
                initialColor: getHslColorFromAngle(angle), // 初期色を設定
                canBeAttacked: false // 2. 敵の挙動と攻撃可否 - 初期は攻撃不可
            });
        }

        function updateEnemies() {
            enemies.forEach(e => {
                e.distance -= e.speed;

                // 2. 敵の挙動と攻撃可否: ゾーンを突破し内側に入った瞬間に彩度がスムーズに上がり、攻撃可能になる
                if (!e.canBeAttacked && e.distance <= attackZoneRadius) {
                    e.canBeAttacked = true;
                    // 4. 視覚・UIの連動演出：攻撃可能になる瞬間にバイブレーション
                    vibrateDevice([50]); // 短い振動
                    generateSound(600, 0.08, 'triangle', 0.4); // ポップな音
                }
                
                // 5. 危険度は振動＋明るさで示す
                if (e.distance < attackZoneRadius * 0.7 && !e.isApproaching) { // ゾーン内の危険な距離
                    e.isApproaching = true;
                    vibrateDevice([30, 20, 30]); // 振動
                    generateSound(440, 0.05, 'sawtooth', 0.3);
                }
            });
            enemies = enemies.filter(e => {
                if (e.distance <= 15) {
                    endGame();
                    return false;
                }
                return true;
            });

            if (comboCount > 0 && performance.now() - lastKillTime > COMBO_RESET_TIME) {
                comboCount = 0;
                comboDisplay.classList.remove("active");
                comboDisplay.style.transition = 'opacity 0.5s ease-out, transform 0.5s cubic-bezier(0.2, 0.8, 0.2, 1)';
                comboDisplay.style.opacity = '0';
                comboDisplay.style.transform = 'translateX(-50%) translateY(20px) scale(0.8) translateZ(18px)';
                document.documentElement.style.setProperty('--combo-saturate', '100%');
                setTimeout(() => {
                    comboDisplay.textContent = "";
                    comboDisplay.style.transition = 'opacity 0.3s ease-out, transform 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275)';
                }, 500);
            }
        }

        // HSLカラーをRGBに変換するヘルパー関数
        function hslToRgb(h, s, l) {
            s /= 100;
            l /= 100;
            let c = (1 - Math.abs(2 * l - 1)) * s,
                x = c * (1 - Math.abs((h / 60) % 2 - 1)),
                m = l - c / 2,
                r = 0,
                g = 0,
                b = 0;

            if (0 <= h && h < 60) {
                r = c; g = x; b = 0;
            } else if (60 <= h && h < 120) {
                r = x; g = c; b = 0;
            } else if (120 <= h && h < 180) {
                r = 0; g = c; b = x;
            } else if (180 <= h && h < 240) {
                r = 0; g = x; b = c;
            } else if (240 <= h && h < 300) {
                r = x; g = 0; b = c;
            } else if (300 <= h && h < 360) {
                r = c; g = 0; b = x;
            }
            r = Math.round((r + m) * 255);
            g = Math.round((g + m) * 255);
            b = Math.round((b + m) * 255);

            return `rgb(${r}, ${g}, ${b})`;
        }


        function drawRadar() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            ctx.save();
            ctx.translate(cx, cy);
            ctx.rotate(-deviceOrientationOffset);
            ctx.translate(-cx, -cy);

            const radarMaxRadius = Math.min(canvas.width, canvas.height) * 0.4;
            const playerCircleRadius = radarMaxRadius * 0.1;
            const lineWidth = 4;

            // レーダーの半透明ガラス質感（プレイヤーのいる中心部分）
            ctx.fillStyle = 'rgba(0, 0, 0, 0.2)';
            ctx.beginPath();
            ctx.arc(cx, cy, radarMaxRadius, 0, 2 * Math.PI);
            ctx.fill();

            // 1. 正円の枠の構造: 緑色の正円の枠（ゾーン）
            ctx.shadowColor = "rgba(0, 255, 90, 0.5)";
            ctx.shadowBlur = 20;
            ctx.shadowOffsetX = 0;
            ctx.shadowOffsetY = 0;
            ctx.strokeStyle = "#00FF5A"; /* 緑色のゾーン枠 */
            ctx.lineWidth = lineWidth + 2;
            ctx.beginPath();
            ctx.arc(cx, cy, attackZoneRadius, 0, 2 * Math.PI); /* ゾーンの半径を使用 */
            ctx.stroke();

            ctx.shadowBlur = 0;
            ctx.shadowColor = "rgba(0, 0, 0, 0)";

            // 扇形のグリーンゾーン（プレイヤーの方向）の描画
            const fanInnerRadius = playerCircleRadius;
            const fanOuterRadius = attackZoneRadius; /* ゾーンの内側まで伸びる */
            const fanAngle = Math.PI * 30 / 180;
            const startAngle = -Math.PI / 2 - fanAngle / 2;
            const endAngle = -Math.PI / 2 + fanAngle / 2;

            const gradient = ctx.createRadialGradient(cx, cy, fanInnerRadius, cx, cy, fanOuterRadius);
            gradient.addColorStop(0, 'rgba(0, 255, 90, 0.8)');
            gradient.addColorStop(0.5, 'rgba(0, 255, 90, 0.5)');
            gradient.addColorStop(0.9, 'rgba(0, 255, 90, 0.1)');
            gradient.addColorStop(1, 'rgba(0, 0, 0, 0)');

            ctx.shadowColor = "rgba(0, 255, 90, 0.5)";
            ctx.shadowBlur = 25;
            ctx.shadowOffsetX = 0;
            ctx.shadowOffsetY = 0;

            ctx.beginPath();
            ctx.moveTo(cx + fanInnerRadius * Math.cos(startAngle), cy + fanInnerRadius * Math.sin(startAngle));
            ctx.arc(cx, cy, fanOuterRadius, startAngle, endAngle);
            ctx.lineTo(cx + fanInnerRadius * Math.cos(endAngle), cy + fanInnerRadius * Math.sin(endAngle));
            ctx.arc(cx, cy, fanInnerRadius, endAngle, startAngle, true);
            ctx.closePath();
            ctx.fillStyle = gradient;
            ctx.fill();

            ctx.shadowBlur = 0;
            ctx.shadowColor = "rgba(0, 0, 0, 0)";


            // 敵（シンプルな幾何学的アイコン）の描画
            enemies.forEach(e => {
                const relativeAngle = e.angle;
                const ex = cx + e.distance * Math.cos(relativeAngle);
                const ey = cy + e.distance * Math.sin(relativeAngle);
                
                const enemySize = radarMaxRadius * 0.025;
                
                let enemyColor;
                let blurAmount = 0; // ぼかし量

                // 2. 敵の挙動と攻撃可否 / 3. 彩度の変化演出
                if (e.canBeAttacked) { // ゾーン内
                    // 危険度に応じて赤から白へ変化
                    const distanceRatioInZone = e.distance / attackZoneRadius; // ゾーン内での比率 0-1
                    if (distanceRatioInZone < 0.3) { // 非常に近い（赤から白へ）
                        const ratio = distanceRatioInZone / 0.3; // 0-1
                        const r = 255;
                        const g = Math.floor(255 * ratio);
                        const b = Math.floor(255 * ratio);
                        enemyColor = `rgb(${r}, ${g}, ${b})`;
                    } else if (distanceRatioInZone < 0.7) { // 近い（オレンジから赤へ）
                        const ratio = (distanceRatioInZone - 0.3) / 0.4; // 0-1
                        const r = 255;
                        const g = Math.floor(255 * (1 - ratio));
                        const b = 0;
                        enemyColor = `rgb(${r}, ${g}, ${b})`;
                    } else { // ゾーンに入ったばかり（彩度MAXの初期色）
                        enemyColor = e.initialColor; // 彩度MAXで鮮やか
                    }
                    blurAmount = 0; // ゾーン内はぼかしなし

                } else { // ゾーン外
                    // 彩度かなり低め（グレー）で軽くぼかし
                    const initialHue = (e.angle / (2 * Math.PI)) * 360;
                    enemyColor = `hsl(${initialHue}, 10%, 30%)`; // 低い彩度と明度でグレー表現
                    blurAmount = 1; // 1pxぼかし
                }
                
                ctx.filter = `blur(${blurAmount}px)`; // ぼかしを適用

                const absoluteShootAngle = normalizeAngle(startAngle + fanAngle / 2 + deviceOrientationOffset);
                const diff = Math.abs(normalizeAngle(e.angle - absoluteShootAngle));
                const currentShootRange = fanAngle;

                // 敵照準でのボーダー色変化（攻撃可能かつ照準に入っている場合）
                if (e.canBeAttacked && diff < currentShootRange / 2 && e.distance < attackZoneRadius) {
                    e.isTargeted = true;
                    ctx.strokeStyle = "#00FF5A";
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.arc(ex, ey, enemySize + 3, 0, 2 * Math.PI);
                    ctx.stroke();
                } else {
                    e.isTargeted = false;
                }
                
                ctx.fillStyle = enemyColor;
                ctx.beginPath();
                ctx.arc(ex, ey, enemySize, 0, 2 * Math.PI);
                ctx.fill();

                ctx.filter = 'none'; // フィルターをリセット
            });

            // 1. 正円の枠の構造: プレイヤーを緑色の円に白いボーダーつきで描画
            ctx.shadowColor = "rgba(0, 255, 90, 0.8)";
            ctx.shadowBlur = 20;
            ctx.shadowOffsetX = 0;
            ctx.shadowOffsetY = 0;
            
            ctx.fillStyle = '#00FF5A'; // プレイヤーの色は明るい緑
            ctx.beginPath();
            ctx.arc(cx, cy, playerCircleRadius, 0, 2 * Math.PI); // 円を描画
            ctx.fill();
            
            ctx.strokeStyle = '#FFFFFF'; // 白いボーダー
            ctx.lineWidth = 3;
            ctx.beginPath();
            ctx.arc(cx, cy, playerCircleRadius + 1, 0, 2 * Math.PI); // 少し大きめの円でボーダー
            ctx.stroke();

            ctx.shadowBlur = 0;
            ctx.shadowColor = "rgba(0, 0, 0, 0)";

            ctx.restore();
        }

        function normalizeAngle(angle) {
            return Math.atan2(Math.sin(angle), Math.cos(angle));
        }

        function gameLoop() {
            if (isGameOver) return;
            updateEnemies();
            drawRadar();
            requestAnimationFrame(gameLoop);
        }

        function createHitParticles(x, y, count = 10) {
            for (let i = 0; i < count; i++) {
                const particle = document.createElement("div");
                particle.className = "hit-particle";
                
                const angle = Math.random() * Math.PI * 2;
                const distance = Math.random() * 50 + 20;
                const size = Math.random() * 8 + 2;
                
                particle.style.left = `${x}px`;
                particle.style.top = `${y}px`;
                particle.style.width = `${size}px`;
                particle.style.height = `${size}px`;
                
                const colors = ['#FF6F61', '#FFD166', '#00B8D4', '#00D1B2', '#E040FB', '#FFFFFF'];
                particle.style.background = colors[Math.floor(Math.random() * colors.length)];
                
                const translateX = distance * Math.cos(angle);
                const translateY = distance * Math.sin(angle);

                particle.style.setProperty('--translate-x', `${translateX}px`);
                particle.style.setProperty('--translate-y', `${translateY}px`);

                document.body.appendChild(particle);
                setTimeout(() => particle.remove(), 600);
            }
        }


        function createRippleEffect(x, y) {
            const ripple = document.createElement("div");
            ripple.className = "ripple-effect";
            ripple.style.left = `${x}px`;
            ripple.style.top = `${y}px`;
            ripple.style.width = ripple.style.height = `min(15vw, 60px)`;
            document.body.appendChild(ripple);
            setTimeout(() => ripple.remove(), 400);
        }

        function updateScore(points) {
            const oldScore = score;
            score += points;
            
            let currentScore = oldScore;
            const diff = score - oldScore;
            const duration = 300;
            const startTime = performance.now();

            function animateScore() {
                const now = performance.now();
                const elapsed = now - startTime;
                if (elapsed < duration) {
                    const progress = elapsed / duration;
                    scoreDisplay.textContent = Math.floor(oldScore + diff * progress).toString();
                    requestAnimationFrame(animateScore);
                } else {
                    scoreDisplay.textContent = score.toString();
                }
            }
            animateScore();

            if (score > 0 && score % 5000 === 0) {
                scoreDisplay.classList.add('vibrate');
                vibrateDevice([50, 20, 50]);
                generateSound(1500, 0.1, 'sine', 0.7);
                setTimeout(() => {
                    scoreDisplay.classList.remove('vibrate');
                }, 300);
            }
        }

        function endGame() {
            if (isGameOver) return;
            isGameOver = true;
            vibrateDevice([200, 100, 200, 100, 200]);
            generateSound(200, 0.4, 'square', 0.6);
            if (enemySpawnInterval) clearInterval(enemySpawnInterval);
            finalScore.textContent = `FINAL SCORE: ${score}`;
            gameOverScreen.classList.add("visible");
            canvas.removeEventListener("click", handleShoot);
            window.removeEventListener("devicemotion", handleDeviceMotion); // ゲーム終了時は解除
        }

        function handleShoot(event) {
            if (isGameOver || shootCooldown) return;
            
            // タップ操作の場合はイベントオブジェクトが存在する
            if (event && event.clientX && event.clientY) {
                createRippleEffect(event.clientX, event.clientY);
            } else {
                // スマホを振る操作の場合は画面中央にエフェクト
                createRippleEffect(cx, cy); 
            }

            generateSound(880, 0.08, 'sine', 0.4);
            vibrateDevice([20, 10, 20]);
            
            shootCooldown = true;
            setTimeout(() => {
                shootCooldown = false;
            }, SHOOT_COOLDOWN_TIME);

            const shootAngle = -Math.PI / 2;
            const fanAngle = Math.PI * 30 / 180;

            enemies = enemies.filter(e => {
                const absoluteShootAngle = normalizeAngle(shootAngle + deviceOrientationOffset);
                const diff = Math.abs(normalizeAngle(e.angle - absoluteShootAngle));

                // 2. ゾーンに入った敵だけが攻撃可能になる
                if (e.canBeAttacked && diff < fanAngle / 2 && e.distance < attackZoneRadius) {
                    e.health--;
                    if (e.health <= 0) {
                        const ex = cx + e.distance * Math.cos(e.angle);
                        const ey = cy + e.distance * Math.sin(e.angle);
                        createHitParticles(ex, ey, 15);
                        
                        const currentTime = performance.now();
                        if (currentTime - lastKillTime < COMBO_RESET_TIME) {
                            comboCount++;
                        } else {
                            comboCount = 1;
                        }
                        lastKillTime = currentTime;

                        let comboText = "";
                        if (comboCount > 1) {
                            comboText = `${comboCount} COMBO!`;
                            comboDisplay.classList.add("active");
                            const saturateValue = Math.min(100 + comboCount * 10, 300);
                            document.documentElement.style.setProperty('--combo-saturate', `${saturateValue}%`);

                            if (comboCount >= 3 && comboCount % 3 === 0) {
                                vibrateDevice([30]);
                                generateSound(1200, 0.05, 'triangle', 0.8);
                            }
                        } else {
                             comboDisplay.classList.remove("active");
                             document.documentElement.style.setProperty('--combo-saturate', '100%');
                        }
                        
                        let currentCombo = parseInt(comboDisplay.textContent.split(' ')[0]) || 0;
                        if (comboCount > currentCombo) {
                            const comboDiff = comboCount - currentCombo;
                            const comboDuration = 200;
                            const comboStartTime = performance.now();

                            function animateCombo() {
                                const now = performance.now();
                                const elapsed = now - comboStartTime;
                                if (elapsed < comboDuration) {
                                    const progress = elapsed / comboDuration;
                                    comboDisplay.textContent = `${Math.floor(currentCombo + comboDiff * progress)} COMBO! ${getComboIcon(Math.floor(currentCombo + comboDiff * progress))}`;
                                    requestAnimationFrame(animateCombo);
                                } else {
                                    comboDisplay.textContent = comboText + getComboIcon(comboCount);
                                }
                            }
                            animateCombo();
                        } else {
                            comboDisplay.textContent = comboText + getComboIcon(comboCount);
                        }

                        let points = 100;
                        if (comboCount >= 2) {
                            points = Math.floor(points * (1 + comboCount * 0.2));
                        }
                        updateScore(points);
                        showScorePopup(ex, ey, points, comboCount);
                        vibrateDevice([40, 30, 40]);
                        generateSound(1000, 0.1, 'triangle', 0.5);
                        return false;
                    }
                }
                return true;
            });
        }

        function getComboIcon(count) {
            if (count >= 10) return '⚡️⚡️⚡️';
            if (count >= 5) return '⚡️⚡️';
            if (count >= 2) return '⚡️';
            return '';
        }

        function showScorePopup(x, y, points, combo) {
            const popup = document.createElement('div');
            popup.className = 'score-popup';
            popup.textContent = `+${points}`;
            popup.style.left = `${x}px`;
            popup.style.top = `${y}px`;
            popup.style.filter = `saturate(${document.documentElement.style.getPropertyValue('--combo-saturate')})`;
            document.body.appendChild(popup);
            setTimeout(() => popup.remove(), 900);
        }

        restartButton.addEventListener("click", () => {
            initGame();
            canvas.addEventListener("click", handleShoot);
            // リトライ時に加速度センサーイベントリスナーを再追加
            window.addEventListener("devicemotion", handleDeviceMotion);
        });

        window.onload = () => {
            setCanvasDimensions();
            startScreen.classList.remove('hidden');
        };

        startScreen.addEventListener('click', requestDeviceOrientationPermissionAndStartGame);

        window.addEventListener('resize', () => {
            setCanvasDimensions();
        });

    </script>
</body>
</html>
