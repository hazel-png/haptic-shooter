<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="UTF-8" />
<title>本格質感マップデモ</title>
<style>
  html, body {
    margin: 0; padding: 0;
    height: 100%;
    background: #222;
    overflow: hidden;
    user-select: none;
    touch-action: none;
    font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Oxygen,
      Ubuntu, Cantarell, "Open Sans", "Helvetica Neue", sans-serif;
  }
  #area {
    width: 100vw;
    height: 100vh;
    position: relative;
    background: linear-gradient(
      to right,
      #555 0%,
      #888 33%,
      #aaa 33%,
      #aaa 66%,
      #555 66%,
      #555 100%
    );
  }
  #trail {
    position: absolute;
    pointer-events: none;
    top: 0; left: 0;
    width: 100%;
    height: 100%;
    mix-blend-mode: screen;
  }
</style>
</head>
<body>
<div id="area"></div>
<canvas id="trail"></canvas>

<script>
(() => {
  const area = document.getElementById("area");
  const trail = document.getElementById("trail");
  const ctx = trail.getContext("2d");

  // canvas サイズ設定
  function resize() {
    trail.width = window.innerWidth;
    trail.height = window.innerHeight;
  }
  window.addEventListener("resize", resize);
  resize();

  let lastTouch = null;
  let lastTime = 0;

  // 質感判定
  function getTextureType(x, width) {
    const ratio = x / width;
    if (ratio < 0.33) return "metal";
    else if (ratio < 0.66) return "fabric";
    else return "rubber";
  }

  // スワイプ速度計算
  function calculateSwipeSpeed(x, y, time) {
    if (!lastTouch || !lastTime) return 0;
    const dx = x - lastTouch.x;
    const dy = y - lastTouch.y;
    const dt = time - lastTime;
    if (dt === 0) return 0;
    return Math.sqrt(dx*dx + dy*dy) / dt;
  }

  // バイブ振動パターン
  function vibrateForTexture(type, speed) {
    if (!("vibrate" in navigator)) return;
    let pattern;
    switch(type) {
      case "metal":
        pattern = speed > 0.5 ? [5, 5, 5, 5] : [10, 20, 10];
        break;
      case "fabric":
        pattern = speed > 0.5 ? [30, 10] : [50];
        break;
      case "rubber":
        pattern = speed > 0.5 ? [80, 20, 80] : [100];
        break;
    }
    navigator.vibrate(pattern);
  }

  // 音響セットアップ
  const audioCtx = new (window.AudioContext || window.webkitAudioContext)();

  function playFilteredNoise(type, speed) {
    const bufferSize = 4096;
    const noise = audioCtx.createScriptProcessor(bufferSize, 1, 1);

    const filter = audioCtx.createBiquadFilter();
    if (type === "metal") {
      filter.type = "highpass";
      filter.frequency.value = 2000;
    } else if (type === "fabric") {
      filter.type = "lowpass";
      filter.frequency.value = 800;
    } else {
      filter.type = "bandpass";
      filter.frequency.value = 500;
    }

    noise.onaudioprocess = e => {
      const output = e.outputBuffer.getChannelData(0);
      for (let i = 0; i < bufferSize; i++) {
        output[i] = (Math.random() * 2 - 1) * (speed / 3);
      }
    };

    noise.connect(filter);
    filter.connect(audioCtx.destination);

    setTimeout(() => {
      noise.disconnect();
      filter.disconnect();
    }, 500);
  }

  // 視覚エフェクト：スワイプ軌跡描画
  function updateVisualEffect(type, x, y) {
    let color;
    switch(type) {
      case "metal":
        color = "rgba(200, 200, 255, 0.7)";
        break;
      case "fabric":
        color = "rgba(200, 255, 200, 0.7)";
        break;
      case "rubber":
        color = "rgba(255, 200, 200, 0.7)";
        break;
    }
    ctx.fillStyle = color;
    ctx.beginPath();
    ctx.arc(x, y, 10, 0, 2 * Math.PI);
    ctx.fill();
  }

  // 軌跡を徐々に消す処理
  function fadeTrail() {
    ctx.fillStyle = "rgba(34, 34, 34, 0.15)";
    ctx.fillRect(0, 0, trail.width, trail.height);
    requestAnimationFrame(fadeTrail);
  }
  fadeTrail();

  area.addEventListener("touchmove", e => {
    e.preventDefault();
    const touch = e.touches[0];
    const x = touch.clientX;
    const y = touch.clientY;
    const now = performance.now();

    const speed = calculateSwipeSpeed(x, y, now);
    const type = getTextureType(x, window.innerWidth);

    vibrateForTexture(type, speed);
    playFilteredNoise(type, speed);
    updateVisualEffect(type, x, y);

    lastTouch = { x, y };
    lastTime = now;
  });

  // audioCtxの自動サスペンド回避（iOSなど）
  document.body.addEventListener('touchstart', () => {
    if (audioCtx.state === 'suspended') {
      audioCtx.resume();
    }
  });
})();
</script>
</body>
</html>
